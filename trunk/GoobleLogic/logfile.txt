Adding statement: <<woman[CONST:adele]>>
Adding statement: <<woman[CONST:jane]>>
Adding statement: <<woman[CONST:laura]>>
Adding statement: <<woman[CONST:molly]>>
Adding statement: <<woman[CONST:sarah]>>
Adding statement: <<house[CONST:1]>>
Adding statement: <<house[CONST:3]>>
Adding statement: <<house[CONST:2]>>
Adding statement: <<house[CONST:4]>>
Adding statement: <<house[CONST:5]>>
Adding statement: <<directlyEastOf[CONST:1, CONST:2]>>
Adding statement: <<directlyEastOf[CONST:3, CONST:4]>>
Adding statement: <<nextTo[CONST:1, CONST:3]>>
Adding statement: <<nextTo[CONST:3, CONST:1]>>
Adding statement: <<nextTo[CONST:2, CONST:4]>>
Adding statement: <<nextTo[CONST:4, CONST:2]>>
Adding statement: <<nextTo[CONST:4, CONST:5]>>
Adding statement: <<nextTo[CONST:5, CONST:4]>>
Adding rule: <<[house[VAR:X], house[VAR:Y], (VAR:X > VAR:Y)] => northOf[VAR:X, VAR:Y]>>
Adding rule: <<[house[VAR:X], house[VAR:Y], (VAR:X < VAR:Y)] => southOf[VAR:X, VAR:Y]>>
Adding statement: <<hairColour[CONST:black]>>
Adding statement: <<hairColour[CONST:blonde]>>
Adding statement: <<hairColour[CONST:brown]>>
Adding statement: <<hairColour[CONST:chestnut]>>
Adding statement: <<hairColour[CONST:grey]>>
Adding rule: <<[house[VAR:X], woman[VAR:Y]] => livesAtHouse[VAR:X, VAR:Y]>>
Adding rule: <<[hairColour[VAR:C], woman[VAR:W]] => hairOf[VAR:W, VAR:C]>>
Adding rule: <<[hairOf[VAR:W1, CONST:blonde], livesAtHouse[VAR:H1, VAR:W1], nextTo[VAR:H1, VAR:H2], southOf[VAR:H2, VAR:H1], livesAtHouse[VAR:H2, CONST:adele], directlyEastOf[VAR:H3, VAR:H2], livesAtHouse[VAR:H3, CONST:laura]] => solution1[VAR:W1, VAR:H1, VAR:H2, VAR:H3]>>
Adding rule: <<[livesAtHouse[VAR:H4, CONST:sarah], nextTo[VAR:H5, VAR:H4], southOf[VAR:H5, VAR:H4], livesAtHouse[VAR:H5, CONST:molly]] => solution2[VAR:H4, VAR:H5]>>
Adding rule: <<[livesAtHouse[VAR:H6, VAR:W2], directlyEastOf[VAR:H7, VAR:H6], livesAtHouse[VAR:H7, CONST:jane], northOf[VAR:H8, VAR:H7], livesAtHouse[VAR:H8, VAR:W3], hairOf[VAR:W3, CONST:grey]] => solution3[VAR:H6, VAR:W2, VAR:H7, VAR:H8, VAR:W3]>>
Adding rule: <<[hairOf[VAR:W4, CONST:chestnut], livesAtHouse[VAR:H9, VAR:W4], nextTo[VAR:H10, VAR:H9], northOf[VAR:H10, VAR:H9], livesAtHouse[VAR:H10, VAR:W5], hairOf[VAR:W5, CONST:black]] => solution4[VAR:W4, VAR:H9, VAR:H10, VAR:W5]>>
---------
Begin find solutions on statement: <<solution1[VAR:W1, VAR:H1, VAR:H2, VAR:H3]>>

Matches statement? false

Applying rules for <<solution1[VAR:W1, VAR:H1, VAR:H2, VAR:H3]>>

proving antecedent : <<hairOf[VAR:W1, CONST:blonde]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairOf[VAR:W1, CONST:blonde]>>

Matches statement? false

Applying rules for <<hairOf[VAR:W1, CONST:blonde]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:blonde]>>

statement : <<hairColour[CONST:blonde]>> matched <<hairColour[CONST:blonde]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:W]>>

statement : <<woman[VAR:W]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:W]>> : solution: <<SOLUTION: [(VAR:W=CONST:adele)]>>
statement : <<woman[VAR:W]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:W]>> : solution: <<SOLUTION: [(VAR:W=CONST:jane)]>>
statement : <<woman[VAR:W]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:W]>> : solution: <<SOLUTION: [(VAR:W=CONST:laura)]>>
statement : <<woman[VAR:W]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:W]>> : solution: <<SOLUTION: [(VAR:W=CONST:molly)]>>
statement : <<woman[VAR:W]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:W]>> : solution: <<SOLUTION: [(VAR:W=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[VAR:W1, CONST:blonde]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah)]
>>

proving antecedent : <<livesAtHouse[VAR:H1, VAR:W1]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah)]
>> with replacements <<[(VAR:W1=VAR:W1), (VAR:H1=VAR:H1), (VAR:H2=VAR:H2), (VAR:H3=VAR:H3)]>>
current statement to prove while expanding: <<livesAtHouse[VAR:H1, VAR:W1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah)]>>
Fully unified: livesAtHouse[VAR:H1, CONST:sarah]
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H1, CONST:sarah]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H1, CONST:sarah]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:sarah)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H1, CONST:sarah]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H1=CONST:1)]
SOLUTION: [(VAR:H1=CONST:3)]
SOLUTION: [(VAR:H1=CONST:2)]
SOLUTION: [(VAR:H1=CONST:4)]
SOLUTION: [(VAR:H1=CONST:5)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H1, VAR:W1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly)]>>
Fully unified: livesAtHouse[VAR:H1, CONST:molly]
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H1, CONST:molly]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H1, CONST:molly]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:molly)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[CONST:molly]
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[CONST:molly]
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[CONST:molly]
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[CONST:molly]
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[CONST:molly]
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H1, CONST:molly]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H1=CONST:1)]
SOLUTION: [(VAR:H1=CONST:3)]
SOLUTION: [(VAR:H1=CONST:2)]
SOLUTION: [(VAR:H1=CONST:4)]
SOLUTION: [(VAR:H1=CONST:5)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H1, VAR:W1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura)]>>
Fully unified: livesAtHouse[VAR:H1, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H1, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H1, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:laura)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[CONST:laura]
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[CONST:laura]
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[CONST:laura]
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[CONST:laura]
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[CONST:laura]
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H1, CONST:laura]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H1=CONST:1)]
SOLUTION: [(VAR:H1=CONST:3)]
SOLUTION: [(VAR:H1=CONST:2)]
SOLUTION: [(VAR:H1=CONST:4)]
SOLUTION: [(VAR:H1=CONST:5)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H1, VAR:W1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane)]>>
Fully unified: livesAtHouse[VAR:H1, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H1, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H1, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:jane)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[CONST:jane]
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[CONST:jane]
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[CONST:jane]
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[CONST:jane]
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[CONST:jane]
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H1, CONST:jane]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H1=CONST:1)]
SOLUTION: [(VAR:H1=CONST:3)]
SOLUTION: [(VAR:H1=CONST:2)]
SOLUTION: [(VAR:H1=CONST:4)]
SOLUTION: [(VAR:H1=CONST:5)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H1, VAR:W1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele)]>>
Fully unified: livesAtHouse[VAR:H1, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H1, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H1, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:adele)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[CONST:adele]
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[CONST:adele]
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[CONST:adele]
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[CONST:adele]
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[CONST:adele]
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H1, CONST:adele]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H1=CONST:1)]
SOLUTION: [(VAR:H1=CONST:3)]
SOLUTION: [(VAR:H1=CONST:2)]
SOLUTION: [(VAR:H1=CONST:4)]
SOLUTION: [(VAR:H1=CONST:5)]
>>

expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]

proving antecedent : <<nextTo[VAR:H1, VAR:H2]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]
>> with replacements <<[(VAR:W1=VAR:W1), (VAR:H1=VAR:H1), (VAR:H2=VAR:H2), (VAR:H3=VAR:H3)]>>
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[CONST:5, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:5, VAR:H2]>>

statement : <<nextTo[CONST:5, VAR:H2]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[CONST:5, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[CONST:4, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:4, VAR:H2]>>

statement : <<nextTo[CONST:4, VAR:H2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[CONST:4, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[CONST:4, VAR:H2]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[CONST:4, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[CONST:2, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:2, VAR:H2]>>

statement : <<nextTo[CONST:2, VAR:H2]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[CONST:2, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[CONST:3, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:3, VAR:H2]>>

statement : <<nextTo[CONST:3, VAR:H2]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[CONST:3, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[CONST:1, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:1, VAR:H2]>>

statement : <<nextTo[CONST:1, VAR:H2]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[CONST:1, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[CONST:5, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:5, VAR:H2]>>

statement : <<nextTo[CONST:5, VAR:H2]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[CONST:5, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[CONST:4, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:4, VAR:H2]>>

statement : <<nextTo[CONST:4, VAR:H2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[CONST:4, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[CONST:4, VAR:H2]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[CONST:4, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[CONST:2, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:2, VAR:H2]>>

statement : <<nextTo[CONST:2, VAR:H2]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[CONST:2, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[CONST:3, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:3, VAR:H2]>>

statement : <<nextTo[CONST:3, VAR:H2]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[CONST:3, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[CONST:1, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:1, VAR:H2]>>

statement : <<nextTo[CONST:1, VAR:H2]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[CONST:1, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[CONST:5, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:5, VAR:H2]>>

statement : <<nextTo[CONST:5, VAR:H2]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[CONST:5, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[CONST:4, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:4, VAR:H2]>>

statement : <<nextTo[CONST:4, VAR:H2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[CONST:4, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[CONST:4, VAR:H2]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[CONST:4, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[CONST:2, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:2, VAR:H2]>>

statement : <<nextTo[CONST:2, VAR:H2]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[CONST:2, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[CONST:3, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:3, VAR:H2]>>

statement : <<nextTo[CONST:3, VAR:H2]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[CONST:3, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[CONST:1, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:1, VAR:H2]>>

statement : <<nextTo[CONST:1, VAR:H2]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[CONST:1, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[CONST:5, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:5, VAR:H2]>>

statement : <<nextTo[CONST:5, VAR:H2]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[CONST:5, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[CONST:4, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:4, VAR:H2]>>

statement : <<nextTo[CONST:4, VAR:H2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[CONST:4, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[CONST:4, VAR:H2]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[CONST:4, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[CONST:2, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:2, VAR:H2]>>

statement : <<nextTo[CONST:2, VAR:H2]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[CONST:2, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[CONST:3, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:3, VAR:H2]>>

statement : <<nextTo[CONST:3, VAR:H2]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[CONST:3, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[CONST:1, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:1, VAR:H2]>>

statement : <<nextTo[CONST:1, VAR:H2]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[CONST:1, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[CONST:5, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:5, VAR:H2]>>

statement : <<nextTo[CONST:5, VAR:H2]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[CONST:5, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[CONST:4, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:4, VAR:H2]>>

statement : <<nextTo[CONST:4, VAR:H2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[CONST:4, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[CONST:4, VAR:H2]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[CONST:4, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[CONST:2, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:2, VAR:H2]>>

statement : <<nextTo[CONST:2, VAR:H2]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[CONST:2, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[CONST:3, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:3, VAR:H2]>>

statement : <<nextTo[CONST:3, VAR:H2]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[CONST:3, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H1, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[CONST:1, VAR:H2]
---------
Begin find solutions on statement: <<nextTo[CONST:1, VAR:H2]>>

statement : <<nextTo[CONST:1, VAR:H2]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[CONST:1, VAR:H2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]

proving antecedent : <<southOf[VAR:H2, VAR:H1]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
>> with replacements <<[(VAR:W1=VAR:W1), (VAR:H1=VAR:H1), (VAR:H2=VAR:H2), (VAR:H3=VAR:H3)]>>
current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

proving antecedent : <<livesAtHouse[VAR:H2, CONST:adele]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
>> with replacements <<[(VAR:W1=VAR:W1), (VAR:H1=VAR:H1), (VAR:H2=VAR:H2), (VAR:H3=VAR:H3)]>>
current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: livesAtHouse[CONST:2, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:2, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:2, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:2, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: livesAtHouse[CONST:2, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:2, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:2, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:2, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: livesAtHouse[CONST:2, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:2, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:2, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:2, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: livesAtHouse[CONST:2, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:2, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:2, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:2, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: livesAtHouse[CONST:2, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:2, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:2, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:2, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H2, CONST:adele]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, CONST:adele]>> : <<QUERY true, SOLUTIONS: >>

proving antecedent : <<directlyEastOf[VAR:H3, VAR:H2]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
>> with replacements <<[(VAR:W1=VAR:W1), (VAR:H1=VAR:H1), (VAR:H2=VAR:H2), (VAR:H3=VAR:H3)]>>
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H3, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:2]>>

statement : <<directlyEastOf[VAR:H3, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H3, CONST:2]>> : solution: <<SOLUTION: [(VAR:H3=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:4]>>

statement : <<directlyEastOf[VAR:H3, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H3, CONST:4]>> : solution: <<SOLUTION: [(VAR:H3=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H3, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:2]>>

statement : <<directlyEastOf[VAR:H3, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H3, CONST:2]>> : solution: <<SOLUTION: [(VAR:H3=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:4]>>

statement : <<directlyEastOf[VAR:H3, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H3, CONST:4]>> : solution: <<SOLUTION: [(VAR:H3=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H3, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:2]>>

statement : <<directlyEastOf[VAR:H3, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H3, CONST:2]>> : solution: <<SOLUTION: [(VAR:H3=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:4]>>

statement : <<directlyEastOf[VAR:H3, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H3, CONST:4]>> : solution: <<SOLUTION: [(VAR:H3=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H3, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:2]>>

statement : <<directlyEastOf[VAR:H3, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H3, CONST:2]>> : solution: <<SOLUTION: [(VAR:H3=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:4]>>

statement : <<directlyEastOf[VAR:H3, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H3, CONST:4]>> : solution: <<SOLUTION: [(VAR:H3=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H3, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:2]>>

statement : <<directlyEastOf[VAR:H3, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H3, CONST:2]>> : solution: <<SOLUTION: [(VAR:H3=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:4]>>

statement : <<directlyEastOf[VAR:H3, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H3, CONST:4]>> : solution: <<SOLUTION: [(VAR:H3=CONST:3)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]

proving antecedent : <<livesAtHouse[VAR:H3, CONST:laura]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
>> with replacements <<[(VAR:W1=VAR:W1), (VAR:H1=VAR:H1), (VAR:H2=VAR:H2), (VAR:H3=VAR:H3)]>>
current statement to prove while expanding: <<livesAtHouse[VAR:H3, CONST:laura]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, CONST:laura]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H3, CONST:laura]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:laura]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H3, CONST:laura]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, CONST:laura]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H3, CONST:laura]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:laura]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H3, CONST:laura]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, CONST:laura]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H3, CONST:laura]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:laura]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H3, CONST:laura]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, CONST:laura]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H3, CONST:laura]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:laura]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H3, CONST:laura]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, CONST:laura]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H3, CONST:laura]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:laura]>> : <<QUERY true, SOLUTIONS: >>

at least one rule succeeded? true
final solution for statement <<solution1[VAR:W1, VAR:H1, VAR:H2, VAR:H3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
>>

---------
Begin find solutions on statement: <<solution2[VAR:H4, VAR:H5]>>

Matches statement? false

Applying rules for <<solution2[VAR:H4, VAR:H5]>>

proving antecedent : <<livesAtHouse[VAR:H4, CONST:sarah]>>

Adding initial solutions
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H4, CONST:sarah]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H4, CONST:sarah]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:sarah)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H4, CONST:sarah]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H4=CONST:1)]
SOLUTION: [(VAR:H4=CONST:3)]
SOLUTION: [(VAR:H4=CONST:2)]
SOLUTION: [(VAR:H4=CONST:4)]
SOLUTION: [(VAR:H4=CONST:5)]
>>

proving antecedent : <<nextTo[VAR:H5, VAR:H4]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H4=CONST:1)]
SOLUTION: [(VAR:H4=CONST:3)]
SOLUTION: [(VAR:H4=CONST:2)]
SOLUTION: [(VAR:H4=CONST:4)]
SOLUTION: [(VAR:H4=CONST:5)]
>> with replacements <<[(VAR:H4=VAR:H4), (VAR:H5=VAR:H5)]>>
current statement to prove while expanding: <<nextTo[VAR:H5, VAR:H4]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:5)]>>
Fully unified: nextTo[VAR:H5, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H5, CONST:5]>>

statement : <<nextTo[VAR:H5, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H5, CONST:5]>> : solution: <<SOLUTION: [(VAR:H5=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H5, VAR:H4]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:4)]>>
Fully unified: nextTo[VAR:H5, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H5, CONST:4]>>

statement : <<nextTo[VAR:H5, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H5, CONST:4]>> : solution: <<SOLUTION: [(VAR:H5=CONST:2)]>>
statement : <<nextTo[VAR:H5, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H5, CONST:4]>> : solution: <<SOLUTION: [(VAR:H5=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H5, VAR:H4]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:2)]>>
Fully unified: nextTo[VAR:H5, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H5, CONST:2]>>

statement : <<nextTo[VAR:H5, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H5, CONST:2]>> : solution: <<SOLUTION: [(VAR:H5=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H5, VAR:H4]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:3)]>>
Fully unified: nextTo[VAR:H5, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H5, CONST:3]>>

statement : <<nextTo[VAR:H5, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H5, CONST:3]>> : solution: <<SOLUTION: [(VAR:H5=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H5, VAR:H4]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:1)]>>
Fully unified: nextTo[VAR:H5, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H5, CONST:1]>>

statement : <<nextTo[VAR:H5, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H5, CONST:1]>> : solution: <<SOLUTION: [(VAR:H5=CONST:3)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:H4=CONST:5), (VAR:H5=CONST:4)]
SOLUTION: [(VAR:H4=CONST:4), (VAR:H5=CONST:2)]
SOLUTION: [(VAR:H4=CONST:4), (VAR:H5=CONST:5)]
SOLUTION: [(VAR:H4=CONST:2), (VAR:H5=CONST:4)]
SOLUTION: [(VAR:H4=CONST:3), (VAR:H5=CONST:1)]
SOLUTION: [(VAR:H4=CONST:1), (VAR:H5=CONST:3)]

proving antecedent : <<southOf[VAR:H5, VAR:H4]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H4=CONST:5), (VAR:H5=CONST:4)]
SOLUTION: [(VAR:H4=CONST:4), (VAR:H5=CONST:2)]
SOLUTION: [(VAR:H4=CONST:4), (VAR:H5=CONST:5)]
SOLUTION: [(VAR:H4=CONST:2), (VAR:H5=CONST:4)]
SOLUTION: [(VAR:H4=CONST:3), (VAR:H5=CONST:1)]
SOLUTION: [(VAR:H4=CONST:1), (VAR:H5=CONST:3)]
>> with replacements <<[(VAR:H4=VAR:H4), (VAR:H5=VAR:H5)]>>
current statement to prove while expanding: <<southOf[VAR:H5, VAR:H4]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:1), (VAR:H5=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H5, VAR:H4]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:3), (VAR:H5=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H5, VAR:H4]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:2), (VAR:H5=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H5, VAR:H4]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:4), (VAR:H5=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H5, VAR:H4]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:4), (VAR:H5=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H5, VAR:H4]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:5), (VAR:H5=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

proving antecedent : <<livesAtHouse[VAR:H5, CONST:molly]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:H4=CONST:5), (VAR:H5=CONST:4)]
SOLUTION: [(VAR:H4=CONST:4), (VAR:H5=CONST:2)]
SOLUTION: [(VAR:H4=CONST:3), (VAR:H5=CONST:1)]
>> with replacements <<[(VAR:H4=VAR:H4), (VAR:H5=VAR:H5)]>>
current statement to prove while expanding: <<livesAtHouse[VAR:H5, CONST:molly]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:3), (VAR:H5=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:molly]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:molly]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:molly]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:molly]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H5, CONST:molly]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:4), (VAR:H5=CONST:2)]>>
Fully unified: livesAtHouse[CONST:2, CONST:molly]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:2, CONST:molly]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:2, CONST:molly]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:2, CONST:molly]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H5, CONST:molly]>>
Working on solution: <<SOLUTION: [(VAR:H4=CONST:5), (VAR:H5=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, CONST:molly]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, CONST:molly]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, CONST:molly]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, CONST:molly]>> : <<QUERY true, SOLUTIONS: >>

at least one rule succeeded? true
final solution for statement <<solution2[VAR:H4, VAR:H5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H4=CONST:5), (VAR:H5=CONST:4)]
SOLUTION: [(VAR:H4=CONST:4), (VAR:H5=CONST:2)]
SOLUTION: [(VAR:H4=CONST:3), (VAR:H5=CONST:1)]
>>

---------
Begin find solutions on statement: <<solution3[VAR:H6, VAR:W2, VAR:H7, VAR:H8, VAR:W3]>>

Matches statement? false

Applying rules for <<solution3[VAR:H6, VAR:W2, VAR:H7, VAR:H8, VAR:W3]>>

proving antecedent : <<livesAtHouse[VAR:H6, VAR:W2]>>

Adding initial solutions
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H6, VAR:W2]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H6, VAR:W2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=VAR:Y)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[VAR:Y]
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[VAR:Y]
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[VAR:Y]
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[VAR:Y]
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[VAR:Y]
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:5), (VAR:Y=CONST:adele)]
SOLUTION: [(VAR:X=CONST:5), (VAR:Y=CONST:jane)]
SOLUTION: [(VAR:X=CONST:5), (VAR:Y=CONST:laura)]
SOLUTION: [(VAR:X=CONST:5), (VAR:Y=CONST:molly)]
SOLUTION: [(VAR:X=CONST:5), (VAR:Y=CONST:sarah)]
SOLUTION: [(VAR:X=CONST:4), (VAR:Y=CONST:adele)]
SOLUTION: [(VAR:X=CONST:4), (VAR:Y=CONST:jane)]
SOLUTION: [(VAR:X=CONST:4), (VAR:Y=CONST:laura)]
SOLUTION: [(VAR:X=CONST:4), (VAR:Y=CONST:molly)]
SOLUTION: [(VAR:X=CONST:4), (VAR:Y=CONST:sarah)]
SOLUTION: [(VAR:X=CONST:2), (VAR:Y=CONST:adele)]
SOLUTION: [(VAR:X=CONST:2), (VAR:Y=CONST:jane)]
SOLUTION: [(VAR:X=CONST:2), (VAR:Y=CONST:laura)]
SOLUTION: [(VAR:X=CONST:2), (VAR:Y=CONST:molly)]
SOLUTION: [(VAR:X=CONST:2), (VAR:Y=CONST:sarah)]
SOLUTION: [(VAR:X=CONST:3), (VAR:Y=CONST:adele)]
SOLUTION: [(VAR:X=CONST:3), (VAR:Y=CONST:jane)]
SOLUTION: [(VAR:X=CONST:3), (VAR:Y=CONST:laura)]
SOLUTION: [(VAR:X=CONST:3), (VAR:Y=CONST:molly)]
SOLUTION: [(VAR:X=CONST:3), (VAR:Y=CONST:sarah)]
SOLUTION: [(VAR:X=CONST:1), (VAR:Y=CONST:adele)]
SOLUTION: [(VAR:X=CONST:1), (VAR:Y=CONST:jane)]
SOLUTION: [(VAR:X=CONST:1), (VAR:Y=CONST:laura)]
SOLUTION: [(VAR:X=CONST:1), (VAR:Y=CONST:molly)]
SOLUTION: [(VAR:X=CONST:1), (VAR:Y=CONST:sarah)]

at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H6, VAR:W2]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:sarah)]
>>

proving antecedent : <<directlyEastOf[VAR:H7, VAR:H6]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:sarah)]
>> with replacements <<[(VAR:H6=VAR:H6), (VAR:W2=VAR:W2), (VAR:H7=VAR:H7), (VAR:H8=VAR:H8), (VAR:W3=VAR:W3)]>>
current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:sarah)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:molly)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:laura)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:jane)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:1), (VAR:W2=CONST:adele)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:sarah)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:3]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:3]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:3]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:molly)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:3]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:3]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:3]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:laura)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:3]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:3]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:3]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:jane)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:3]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:3]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:3]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:3), (VAR:W2=CONST:adele)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:3]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:3]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:3]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:2]>>

statement : <<directlyEastOf[VAR:H7, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H7, CONST:2]>> : solution: <<SOLUTION: [(VAR:H7=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:2]>>

statement : <<directlyEastOf[VAR:H7, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H7, CONST:2]>> : solution: <<SOLUTION: [(VAR:H7=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:2]>>

statement : <<directlyEastOf[VAR:H7, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H7, CONST:2]>> : solution: <<SOLUTION: [(VAR:H7=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:2]>>

statement : <<directlyEastOf[VAR:H7, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H7, CONST:2]>> : solution: <<SOLUTION: [(VAR:H7=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:2]>>

statement : <<directlyEastOf[VAR:H7, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H7, CONST:2]>> : solution: <<SOLUTION: [(VAR:H7=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:4]>>

statement : <<directlyEastOf[VAR:H7, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H7, CONST:4]>> : solution: <<SOLUTION: [(VAR:H7=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:4]>>

statement : <<directlyEastOf[VAR:H7, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H7, CONST:4]>> : solution: <<SOLUTION: [(VAR:H7=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:4]>>

statement : <<directlyEastOf[VAR:H7, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H7, CONST:4]>> : solution: <<SOLUTION: [(VAR:H7=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:4]>>

statement : <<directlyEastOf[VAR:H7, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H7, CONST:4]>> : solution: <<SOLUTION: [(VAR:H7=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:4]>>

statement : <<directlyEastOf[VAR:H7, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H7, CONST:4]>> : solution: <<SOLUTION: [(VAR:H7=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:5]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:5]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:5]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:5]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:5]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:5]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:5]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:5]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:5]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:5]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:5]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:5]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H7, VAR:H6]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: directlyEastOf[VAR:H7, CONST:5]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H7, CONST:5]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H7, CONST:5]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H7, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3)]

proving antecedent : <<livesAtHouse[VAR:H7, CONST:jane]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3)]
>> with replacements <<[(VAR:H6=VAR:H6), (VAR:W2=VAR:W2), (VAR:H7=VAR:H7), (VAR:H8=VAR:H8), (VAR:W3=VAR:W3)]>>
current statement to prove while expanding: <<livesAtHouse[VAR:H7, CONST:jane]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, CONST:jane]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H7, CONST:jane]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, CONST:jane]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H7, CONST:jane]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, CONST:jane]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H7, CONST:jane]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, CONST:jane]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H7, CONST:jane]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, CONST:jane]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H7, CONST:jane]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:jane]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H7, CONST:jane]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:jane]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H7, CONST:jane]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:jane]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H7, CONST:jane]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:jane]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<livesAtHouse[VAR:H7, CONST:jane]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1)]>>
Fully unified: livesAtHouse[CONST:1, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:1, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:1, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:1, CONST:jane]>> : <<QUERY true, SOLUTIONS: >>

proving antecedent : <<northOf[VAR:H8, VAR:H7]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3)]
>> with replacements <<[(VAR:H6=VAR:H6), (VAR:W2=VAR:W2), (VAR:H7=VAR:H7), (VAR:H8=VAR:H8), (VAR:W3=VAR:W3)]>>
current statement to prove while expanding: <<northOf[VAR:H8, VAR:H7]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3)]>>
Fully unified: northOf[VAR:H8, CONST:3]
---------
Begin find solutions on statement: <<northOf[VAR:H8, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[VAR:H8, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H8, CONST:3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H8=CONST:4)]
SOLUTION: [(VAR:H8=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H8, VAR:H7]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3)]>>
Fully unified: northOf[VAR:H8, CONST:3]
---------
Begin find solutions on statement: <<northOf[VAR:H8, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[VAR:H8, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H8, CONST:3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H8=CONST:4)]
SOLUTION: [(VAR:H8=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H8, VAR:H7]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3)]>>
Fully unified: northOf[VAR:H8, CONST:3]
---------
Begin find solutions on statement: <<northOf[VAR:H8, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[VAR:H8, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H8, CONST:3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H8=CONST:4)]
SOLUTION: [(VAR:H8=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H8, VAR:H7]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3)]>>
Fully unified: northOf[VAR:H8, CONST:3]
---------
Begin find solutions on statement: <<northOf[VAR:H8, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[VAR:H8, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H8, CONST:3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H8=CONST:4)]
SOLUTION: [(VAR:H8=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H8, VAR:H7]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3)]>>
Fully unified: northOf[VAR:H8, CONST:3]
---------
Begin find solutions on statement: <<northOf[VAR:H8, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[VAR:H8, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H8, CONST:3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H8=CONST:4)]
SOLUTION: [(VAR:H8=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H8, VAR:H7]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1)]>>
Fully unified: northOf[VAR:H8, CONST:1]
---------
Begin find solutions on statement: <<northOf[VAR:H8, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[VAR:H8, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:1)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H8, CONST:1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H8=CONST:3)]
SOLUTION: [(VAR:H8=CONST:2)]
SOLUTION: [(VAR:H8=CONST:4)]
SOLUTION: [(VAR:H8=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H8, VAR:H7]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1)]>>
Fully unified: northOf[VAR:H8, CONST:1]
---------
Begin find solutions on statement: <<northOf[VAR:H8, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[VAR:H8, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:1)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H8, CONST:1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H8=CONST:3)]
SOLUTION: [(VAR:H8=CONST:2)]
SOLUTION: [(VAR:H8=CONST:4)]
SOLUTION: [(VAR:H8=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H8, VAR:H7]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1)]>>
Fully unified: northOf[VAR:H8, CONST:1]
---------
Begin find solutions on statement: <<northOf[VAR:H8, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[VAR:H8, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:1)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H8, CONST:1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H8=CONST:3)]
SOLUTION: [(VAR:H8=CONST:2)]
SOLUTION: [(VAR:H8=CONST:4)]
SOLUTION: [(VAR:H8=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H8, VAR:H7]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1)]>>
Fully unified: northOf[VAR:H8, CONST:1]
---------
Begin find solutions on statement: <<northOf[VAR:H8, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[VAR:H8, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:1)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H8, CONST:1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H8=CONST:3)]
SOLUTION: [(VAR:H8=CONST:2)]
SOLUTION: [(VAR:H8=CONST:4)]
SOLUTION: [(VAR:H8=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H8, VAR:H7]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1)]>>
Fully unified: northOf[VAR:H8, CONST:1]
---------
Begin find solutions on statement: <<northOf[VAR:H8, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[VAR:H8, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:1)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H8, CONST:1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H8=CONST:3)]
SOLUTION: [(VAR:H8=CONST:2)]
SOLUTION: [(VAR:H8=CONST:4)]
SOLUTION: [(VAR:H8=CONST:5)]
>>

expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]

proving antecedent : <<livesAtHouse[VAR:H8, VAR:W3]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]
>> with replacements <<[(VAR:H6=VAR:H6), (VAR:W2=VAR:W2), (VAR:H7=VAR:H7), (VAR:H8=VAR:H8), (VAR:W3=VAR:W3)]>>
current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]>>
Fully unified: livesAtHouse[CONST:2, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:2, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:2, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:2, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]>>
Fully unified: livesAtHouse[CONST:2, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:2, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:2, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:2, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]>>
Fully unified: livesAtHouse[CONST:2, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:2, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:2, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:2, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]>>
Fully unified: livesAtHouse[CONST:2, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:2, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:2, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:2, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2)]>>
Fully unified: livesAtHouse[CONST:2, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:2, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:2, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:2, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H8, VAR:W3]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W3]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W3]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W3=CONST:adele)]
SOLUTION: [(VAR:W3=CONST:jane)]
SOLUTION: [(VAR:W3=CONST:laura)]
SOLUTION: [(VAR:W3=CONST:molly)]
SOLUTION: [(VAR:W3=CONST:sarah)]
>>

expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]

proving antecedent : <<hairOf[VAR:W3, CONST:grey]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
>> with replacements <<[(VAR:H6=VAR:H6), (VAR:W2=VAR:W2), (VAR:H7=VAR:H7), (VAR:H8=VAR:H8), (VAR:W3=VAR:W3)]>>
current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W3, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:grey]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:grey]>>

statement : <<hairColour[CONST:grey]>> matched <<hairColour[CONST:grey]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:grey]>> : <<QUERY true, SOLUTIONS: >>

at least one rule succeeded? true
final solution for statement <<solution3[VAR:H6, VAR:W2, VAR:H7, VAR:H8, VAR:W3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:sarah), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:molly), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:laura), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:jane), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:2), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:2), (VAR:W2=CONST:adele), (VAR:H7=CONST:1), (VAR:H8=CONST:3), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:sarah), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:molly), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:laura), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:jane), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:5), (VAR:W3=CONST:sarah)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:adele)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:jane)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:laura)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:molly)]
SOLUTION: [(VAR:H6=CONST:4), (VAR:W2=CONST:adele), (VAR:H7=CONST:3), (VAR:H8=CONST:4), (VAR:W3=CONST:sarah)]
>>

---------
Begin find solutions on statement: <<solution4[VAR:W4, VAR:H9, VAR:H10, VAR:W5]>>

Matches statement? false

Applying rules for <<solution4[VAR:W4, VAR:H9, VAR:H10, VAR:W5]>>

proving antecedent : <<hairOf[VAR:W4, CONST:chestnut]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairOf[VAR:W4, CONST:chestnut]>>

Matches statement? false

Applying rules for <<hairOf[VAR:W4, CONST:chestnut]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:chestnut]>>

statement : <<hairColour[CONST:chestnut]>> matched <<hairColour[CONST:chestnut]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:W]>>

statement : <<woman[VAR:W]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:W]>> : solution: <<SOLUTION: [(VAR:W=CONST:adele)]>>
statement : <<woman[VAR:W]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:W]>> : solution: <<SOLUTION: [(VAR:W=CONST:jane)]>>
statement : <<woman[VAR:W]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:W]>> : solution: <<SOLUTION: [(VAR:W=CONST:laura)]>>
statement : <<woman[VAR:W]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:W]>> : solution: <<SOLUTION: [(VAR:W=CONST:molly)]>>
statement : <<woman[VAR:W]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:W]>> : solution: <<SOLUTION: [(VAR:W=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[VAR:W4, CONST:chestnut]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W4=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:sarah)]
>>

proving antecedent : <<livesAtHouse[VAR:H9, VAR:W4]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W4=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:sarah)]
>> with replacements <<[(VAR:W4=VAR:W4), (VAR:H9=VAR:H9), (VAR:H10=VAR:H10), (VAR:W5=VAR:W5)]>>
current statement to prove while expanding: <<livesAtHouse[VAR:H9, VAR:W4]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah)]>>
Fully unified: livesAtHouse[VAR:H9, CONST:sarah]
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H9, CONST:sarah]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H9, CONST:sarah]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:sarah)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[CONST:sarah]
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H9, CONST:sarah]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H9=CONST:1)]
SOLUTION: [(VAR:H9=CONST:3)]
SOLUTION: [(VAR:H9=CONST:2)]
SOLUTION: [(VAR:H9=CONST:4)]
SOLUTION: [(VAR:H9=CONST:5)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H9, VAR:W4]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly)]>>
Fully unified: livesAtHouse[VAR:H9, CONST:molly]
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H9, CONST:molly]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H9, CONST:molly]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:molly)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[CONST:molly]
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[CONST:molly]
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[CONST:molly]
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[CONST:molly]
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[CONST:molly]
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H9, CONST:molly]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H9=CONST:1)]
SOLUTION: [(VAR:H9=CONST:3)]
SOLUTION: [(VAR:H9=CONST:2)]
SOLUTION: [(VAR:H9=CONST:4)]
SOLUTION: [(VAR:H9=CONST:5)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H9, VAR:W4]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura)]>>
Fully unified: livesAtHouse[VAR:H9, CONST:laura]
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H9, CONST:laura]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H9, CONST:laura]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:laura)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[CONST:laura]
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[CONST:laura]
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[CONST:laura]
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[CONST:laura]
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[CONST:laura]
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H9, CONST:laura]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H9=CONST:1)]
SOLUTION: [(VAR:H9=CONST:3)]
SOLUTION: [(VAR:H9=CONST:2)]
SOLUTION: [(VAR:H9=CONST:4)]
SOLUTION: [(VAR:H9=CONST:5)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H9, VAR:W4]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane)]>>
Fully unified: livesAtHouse[VAR:H9, CONST:jane]
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H9, CONST:jane]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H9, CONST:jane]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:jane)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[CONST:jane]
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[CONST:jane]
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[CONST:jane]
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[CONST:jane]
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[CONST:jane]
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H9, CONST:jane]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H9=CONST:1)]
SOLUTION: [(VAR:H9=CONST:3)]
SOLUTION: [(VAR:H9=CONST:2)]
SOLUTION: [(VAR:H9=CONST:4)]
SOLUTION: [(VAR:H9=CONST:5)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H9, VAR:W4]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele)]>>
Fully unified: livesAtHouse[VAR:H9, CONST:adele]
---------
Begin find solutions on statement: <<livesAtHouse[VAR:H9, CONST:adele]>>

Matches statement? false

Applying rules for <<livesAtHouse[VAR:H9, CONST:adele]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:adele)]>>
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: woman[CONST:adele]
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: woman[CONST:adele]
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: woman[CONST:adele]
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: woman[CONST:adele]
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
current statement to prove while expanding: <<woman[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: woman[CONST:adele]
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[VAR:H9, CONST:adele]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H9=CONST:1)]
SOLUTION: [(VAR:H9=CONST:3)]
SOLUTION: [(VAR:H9=CONST:2)]
SOLUTION: [(VAR:H9=CONST:4)]
SOLUTION: [(VAR:H9=CONST:5)]
>>

expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:3)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:5)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:3)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:5)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:3)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:5)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:3)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:5)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:3)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:5)]

proving antecedent : <<nextTo[VAR:H10, VAR:H9]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:3)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:5)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:3)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:5)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:3)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:5)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:3)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:5)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:3)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:5)]
>> with replacements <<[(VAR:W4=VAR:W4), (VAR:H9=VAR:H9), (VAR:H10=VAR:H10), (VAR:W5=VAR:W5)]>>
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:5)]>>
Fully unified: nextTo[VAR:H10, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:5]>>

statement : <<nextTo[VAR:H10, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H10, CONST:5]>> : solution: <<SOLUTION: [(VAR:H10=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4)]>>
Fully unified: nextTo[VAR:H10, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:4]>>

statement : <<nextTo[VAR:H10, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H10, CONST:4]>> : solution: <<SOLUTION: [(VAR:H10=CONST:2)]>>
statement : <<nextTo[VAR:H10, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H10, CONST:4]>> : solution: <<SOLUTION: [(VAR:H10=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2)]>>
Fully unified: nextTo[VAR:H10, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:2]>>

statement : <<nextTo[VAR:H10, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H10, CONST:2]>> : solution: <<SOLUTION: [(VAR:H10=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:3)]>>
Fully unified: nextTo[VAR:H10, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:3]>>

statement : <<nextTo[VAR:H10, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H10, CONST:3]>> : solution: <<SOLUTION: [(VAR:H10=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1)]>>
Fully unified: nextTo[VAR:H10, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:1]>>

statement : <<nextTo[VAR:H10, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H10, CONST:1]>> : solution: <<SOLUTION: [(VAR:H10=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:5)]>>
Fully unified: nextTo[VAR:H10, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:5]>>

statement : <<nextTo[VAR:H10, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H10, CONST:5]>> : solution: <<SOLUTION: [(VAR:H10=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4)]>>
Fully unified: nextTo[VAR:H10, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:4]>>

statement : <<nextTo[VAR:H10, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H10, CONST:4]>> : solution: <<SOLUTION: [(VAR:H10=CONST:2)]>>
statement : <<nextTo[VAR:H10, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H10, CONST:4]>> : solution: <<SOLUTION: [(VAR:H10=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2)]>>
Fully unified: nextTo[VAR:H10, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:2]>>

statement : <<nextTo[VAR:H10, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H10, CONST:2]>> : solution: <<SOLUTION: [(VAR:H10=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:3)]>>
Fully unified: nextTo[VAR:H10, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:3]>>

statement : <<nextTo[VAR:H10, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H10, CONST:3]>> : solution: <<SOLUTION: [(VAR:H10=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1)]>>
Fully unified: nextTo[VAR:H10, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:1]>>

statement : <<nextTo[VAR:H10, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H10, CONST:1]>> : solution: <<SOLUTION: [(VAR:H10=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:5)]>>
Fully unified: nextTo[VAR:H10, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:5]>>

statement : <<nextTo[VAR:H10, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H10, CONST:5]>> : solution: <<SOLUTION: [(VAR:H10=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4)]>>
Fully unified: nextTo[VAR:H10, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:4]>>

statement : <<nextTo[VAR:H10, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H10, CONST:4]>> : solution: <<SOLUTION: [(VAR:H10=CONST:2)]>>
statement : <<nextTo[VAR:H10, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H10, CONST:4]>> : solution: <<SOLUTION: [(VAR:H10=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2)]>>
Fully unified: nextTo[VAR:H10, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:2]>>

statement : <<nextTo[VAR:H10, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H10, CONST:2]>> : solution: <<SOLUTION: [(VAR:H10=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:3)]>>
Fully unified: nextTo[VAR:H10, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:3]>>

statement : <<nextTo[VAR:H10, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H10, CONST:3]>> : solution: <<SOLUTION: [(VAR:H10=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1)]>>
Fully unified: nextTo[VAR:H10, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:1]>>

statement : <<nextTo[VAR:H10, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H10, CONST:1]>> : solution: <<SOLUTION: [(VAR:H10=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:5)]>>
Fully unified: nextTo[VAR:H10, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:5]>>

statement : <<nextTo[VAR:H10, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H10, CONST:5]>> : solution: <<SOLUTION: [(VAR:H10=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4)]>>
Fully unified: nextTo[VAR:H10, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:4]>>

statement : <<nextTo[VAR:H10, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H10, CONST:4]>> : solution: <<SOLUTION: [(VAR:H10=CONST:2)]>>
statement : <<nextTo[VAR:H10, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H10, CONST:4]>> : solution: <<SOLUTION: [(VAR:H10=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2)]>>
Fully unified: nextTo[VAR:H10, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:2]>>

statement : <<nextTo[VAR:H10, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H10, CONST:2]>> : solution: <<SOLUTION: [(VAR:H10=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:3)]>>
Fully unified: nextTo[VAR:H10, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:3]>>

statement : <<nextTo[VAR:H10, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H10, CONST:3]>> : solution: <<SOLUTION: [(VAR:H10=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1)]>>
Fully unified: nextTo[VAR:H10, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:1]>>

statement : <<nextTo[VAR:H10, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H10, CONST:1]>> : solution: <<SOLUTION: [(VAR:H10=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:5)]>>
Fully unified: nextTo[VAR:H10, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:5]>>

statement : <<nextTo[VAR:H10, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H10, CONST:5]>> : solution: <<SOLUTION: [(VAR:H10=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4)]>>
Fully unified: nextTo[VAR:H10, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:4]>>

statement : <<nextTo[VAR:H10, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H10, CONST:4]>> : solution: <<SOLUTION: [(VAR:H10=CONST:2)]>>
statement : <<nextTo[VAR:H10, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H10, CONST:4]>> : solution: <<SOLUTION: [(VAR:H10=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2)]>>
Fully unified: nextTo[VAR:H10, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:2]>>

statement : <<nextTo[VAR:H10, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H10, CONST:2]>> : solution: <<SOLUTION: [(VAR:H10=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:3)]>>
Fully unified: nextTo[VAR:H10, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:3]>>

statement : <<nextTo[VAR:H10, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H10, CONST:3]>> : solution: <<SOLUTION: [(VAR:H10=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1)]>>
Fully unified: nextTo[VAR:H10, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H10, CONST:1]>>

statement : <<nextTo[VAR:H10, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H10, CONST:1]>> : solution: <<SOLUTION: [(VAR:H10=CONST:3)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]

proving antecedent : <<northOf[VAR:H10, VAR:H9]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
>> with replacements <<[(VAR:W4=VAR:W4), (VAR:H9=VAR:H9), (VAR:H10=VAR:H10), (VAR:W5=VAR:W5)]>>
current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]>>
Fully unified: northOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<northOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:3, CONST:1]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]>>
Fully unified: northOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<northOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:1, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:2)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:4, CONST:2]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]>>
Fully unified: northOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:5, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]>>
Fully unified: northOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:2, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:5)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:4, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]>>
Fully unified: northOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<northOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:3, CONST:1]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]>>
Fully unified: northOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<northOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:1, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:2)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:4, CONST:2]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]>>
Fully unified: northOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:5, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]>>
Fully unified: northOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:2, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:5)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:4, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]>>
Fully unified: northOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<northOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:3, CONST:1]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]>>
Fully unified: northOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<northOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:1, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:2)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:4, CONST:2]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]>>
Fully unified: northOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:5, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]>>
Fully unified: northOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:2, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:5)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:4, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]>>
Fully unified: northOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<northOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:3, CONST:1]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]>>
Fully unified: northOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<northOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:1, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:2)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:4, CONST:2]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]>>
Fully unified: northOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:5, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]>>
Fully unified: northOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:2, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:5)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:4, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]>>
Fully unified: northOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<northOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:3, CONST:1]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:3), (VAR:H10=CONST:1)]>>
Fully unified: northOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<northOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:1, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:2)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:4, CONST:2]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]>>
Fully unified: northOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:5, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:2)]>>
Fully unified: northOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:2, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H10, VAR:H9]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:5), (VAR:H10=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:5)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:4, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

proving antecedent : <<livesAtHouse[VAR:H10, VAR:W5]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]
>> with replacements <<[(VAR:W4=VAR:W4), (VAR:H9=VAR:H9), (VAR:H10=VAR:H10), (VAR:W5=VAR:W5)]>>
current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3)]>>
Fully unified: livesAtHouse[CONST:3, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:3, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:3, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:3, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4)]>>
Fully unified: livesAtHouse[CONST:4, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:4, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:4, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:4, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

current statement to prove while expanding: <<livesAtHouse[VAR:H10, VAR:W5]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5)]>>
Fully unified: livesAtHouse[CONST:5, VAR:W5]
---------
Begin find solutions on statement: <<livesAtHouse[CONST:5, VAR:W5]>>

Matches statement? false

Applying rules for <<livesAtHouse[CONST:5, VAR:W5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<woman[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[VAR:Y]>>

statement : <<woman[VAR:Y]>> matched <<woman[CONST:adele]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:adele)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:jane]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:jane)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:laura]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:laura)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:molly]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:molly)]>>
statement : <<woman[VAR:Y]>> matched <<woman[CONST:sarah]>>
added solution for <<woman[VAR:Y]>> : solution: <<SOLUTION: [(VAR:Y=CONST:sarah)]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<livesAtHouse[CONST:5, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W5=CONST:sarah)]
>>

expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]

proving antecedent : <<hairOf[VAR:W5, CONST:black]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
>> with replacements <<[(VAR:W4=VAR:W4), (VAR:H9=VAR:H9), (VAR:H10=VAR:H10), (VAR:W5=VAR:W5)]>>
current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:sarah, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:sarah]>>

statement : <<woman[CONST:sarah]>> matched <<woman[CONST:sarah]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:sarah, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:molly, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:molly]>>

statement : <<woman[CONST:molly]>> matched <<woman[CONST:molly]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:molly, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:laura, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:laura]>>

statement : <<woman[CONST:laura]>> matched <<woman[CONST:laura]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:laura, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:jane, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:jane]>>

statement : <<woman[CONST:jane]>> matched <<woman[CONST:jane]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:jane, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<hairOf[VAR:W5, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

Matches statement? false

Applying rules for <<hairOf[CONST:adele, CONST:black]>>

proving antecedent : <<hairColour[VAR:C]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairColour[CONST:black]>>

statement : <<hairColour[CONST:black]>> matched <<hairColour[CONST:black]>>
Matches statement? true
proving antecedent : <<woman[VAR:W]>>

Adding initial solutions
---------
Begin find solutions on statement: <<woman[CONST:adele]>>

statement : <<woman[CONST:adele]>> matched <<woman[CONST:adele]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hairOf[CONST:adele, CONST:black]>> : <<QUERY true, SOLUTIONS: >>

at least one rule succeeded? true
final solution for statement <<solution4[VAR:W4, VAR:H9, VAR:H10, VAR:W5]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:sarah), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:molly), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:laura), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:jane), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:1), (VAR:H10=CONST:3), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:2), (VAR:H10=CONST:4), (VAR:W5=CONST:sarah)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:adele)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:jane)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:laura)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:molly)]
SOLUTION: [(VAR:W4=CONST:adele), (VAR:H9=CONST:4), (VAR:H10=CONST:5), (VAR:W5=CONST:sarah)]
>>

