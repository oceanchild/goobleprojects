Adding statement: <<woman[CONST:adele]>>
Adding statement: <<woman[CONST:jane]>>
Adding statement: <<woman[CONST:laura]>>
Adding statement: <<woman[CONST:molly]>>
Adding statement: <<woman[CONST:sarah]>>
Adding statement: <<house[CONST:1]>>
Adding statement: <<house[CONST:2]>>
Adding statement: <<house[CONST:3]>>
Adding statement: <<house[CONST:4]>>
Adding statement: <<house[CONST:5]>>
Adding statement: <<hair[CONST:black]>>
Adding statement: <<hair[CONST:blonde]>>
Adding statement: <<hair[CONST:brown]>>
Adding statement: <<hair[CONST:chestnut]>>
Adding statement: <<hair[CONST:grey]>>
Adding statement: <<hairOf[CONST:adele, CONST:black]>>
Adding statement: <<hairOf[CONST:adele, CONST:blonde]>>
Adding statement: <<hairOf[CONST:adele, CONST:brown]>>
Adding statement: <<hairOf[CONST:adele, CONST:chestnut]>>
Adding statement: <<hairOf[CONST:adele, CONST:grey]>>
Adding statement: <<houseOf[CONST:adele, CONST:1]>>
Adding statement: <<houseOf[CONST:adele, CONST:2]>>
Adding statement: <<houseOf[CONST:adele, CONST:3]>>
Adding statement: <<houseOf[CONST:adele, CONST:4]>>
Adding statement: <<houseOf[CONST:adele, CONST:5]>>
Adding statement: <<hairOf[CONST:jane, CONST:black]>>
Adding statement: <<hairOf[CONST:jane, CONST:blonde]>>
Adding statement: <<hairOf[CONST:jane, CONST:brown]>>
Adding statement: <<hairOf[CONST:jane, CONST:chestnut]>>
Adding statement: <<hairOf[CONST:jane, CONST:grey]>>
Adding statement: <<houseOf[CONST:jane, CONST:1]>>
Adding statement: <<houseOf[CONST:jane, CONST:2]>>
Adding statement: <<houseOf[CONST:jane, CONST:3]>>
Adding statement: <<houseOf[CONST:jane, CONST:4]>>
Adding statement: <<houseOf[CONST:jane, CONST:5]>>
Adding statement: <<hairOf[CONST:laura, CONST:black]>>
Adding statement: <<hairOf[CONST:laura, CONST:blonde]>>
Adding statement: <<hairOf[CONST:laura, CONST:brown]>>
Adding statement: <<hairOf[CONST:laura, CONST:chestnut]>>
Adding statement: <<hairOf[CONST:laura, CONST:grey]>>
Adding statement: <<houseOf[CONST:laura, CONST:1]>>
Adding statement: <<houseOf[CONST:laura, CONST:2]>>
Adding statement: <<houseOf[CONST:laura, CONST:3]>>
Adding statement: <<houseOf[CONST:laura, CONST:4]>>
Adding statement: <<houseOf[CONST:laura, CONST:5]>>
Adding statement: <<hairOf[CONST:molly, CONST:black]>>
Adding statement: <<hairOf[CONST:molly, CONST:blonde]>>
Adding statement: <<hairOf[CONST:molly, CONST:brown]>>
Adding statement: <<hairOf[CONST:molly, CONST:chestnut]>>
Adding statement: <<hairOf[CONST:molly, CONST:grey]>>
Adding statement: <<houseOf[CONST:molly, CONST:1]>>
Adding statement: <<houseOf[CONST:molly, CONST:2]>>
Adding statement: <<houseOf[CONST:molly, CONST:3]>>
Adding statement: <<houseOf[CONST:molly, CONST:4]>>
Adding statement: <<houseOf[CONST:molly, CONST:5]>>
Adding statement: <<hairOf[CONST:sarah, CONST:black]>>
Adding statement: <<hairOf[CONST:sarah, CONST:blonde]>>
Adding statement: <<hairOf[CONST:sarah, CONST:brown]>>
Adding statement: <<hairOf[CONST:sarah, CONST:chestnut]>>
Adding statement: <<hairOf[CONST:sarah, CONST:grey]>>
Adding statement: <<houseOf[CONST:sarah, CONST:1]>>
Adding statement: <<houseOf[CONST:sarah, CONST:2]>>
Adding statement: <<houseOf[CONST:sarah, CONST:3]>>
Adding statement: <<houseOf[CONST:sarah, CONST:4]>>
Adding statement: <<houseOf[CONST:sarah, CONST:5]>>
Adding rule: <<[hairOf[CONST:adele, VAR:ADELEHAIR], houseOf[CONST:adele, VAR:ADELEHOUSE]] => solution1[VAR:ADELEHAIR, VAR:ADELEHOUSE]>>
Adding rule: <<[hairOf[CONST:jane, VAR:JANEHAIR], houseOf[CONST:jane, VAR:JANEHOUSE]] => solution2[VAR:JANEHAIR, VAR:JANEHOUSE]>>
Adding rule: <<[hairOf[CONST:laura, VAR:LAURAHAIR], houseOf[CONST:laura, VAR:LAURAHOUSE]] => solution3[VAR:LAURAHAIR, VAR:LAURAHOUSE]>>
Adding rule: <<[hairOf[CONST:molly, VAR:MOLLYHAIR], houseOf[CONST:molly, VAR:MOLLYHOUSE]] => solution4[VAR:MOLLYHAIR, VAR:MOLLYHOUSE]>>
Adding rule: <<[hairOf[CONST:sarah, VAR:SARAHHAIR], houseOf[CONST:sarah, VAR:SARAHHOUSE]] => solution5[VAR:SARAHHAIR, VAR:SARAHHOUSE]>>
Adding rule: <<[hairOf[VAR:W1, CONST:blonde], houseOf[VAR:W1, VAR:H1], nextTo[VAR:H2, VAR:H1], southOf[VAR:H2, VAR:H1], houseOf[CONST:adele, VAR:H2], directlyEastOf[VAR:H3, VAR:H2], houseOf[CONST:laura, VAR:H3]] => hint1[VAR:H3, VAR:W1, VAR:H2, VAR:H1]>>
Adding rule: <<[houseOf[CONST:sarah, VAR:H1], nextTo[VAR:H2, VAR:H1], southOf[VAR:H2, VAR:H1], houseOf[CONST:molly, VAR:H2]] => hint2[VAR:H2, VAR:H1]>>
Adding rule: <<[houseOf[VAR:W1, VAR:H1], directlyEastOf[VAR:H2, VAR:H1], houseOf[CONST:jane, VAR:H2], northOf[VAR:H3, VAR:H2], houseOf[VAR:W2, VAR:H3], hairOf[VAR:W2, CONST:grey]] => hint3[VAR:H3, VAR:W1, VAR:W2, VAR:H2, VAR:H1]>>
Adding rule: <<[hairOf[VAR:W1, CONST:chestnut], houseOf[VAR:W1, VAR:H1], nextTo[VAR:H2, VAR:H1], northOf[VAR:H2, VAR:H1], houseOf[VAR:W2, VAR:H2], hairOf[VAR:W2, CONST:black]] => hint4[VAR:W1, VAR:W2, VAR:H2, VAR:H1]>>
Adding statement: <<nextTo[CONST:1, CONST:3]>>
Adding statement: <<nextTo[CONST:3, CONST:1]>>
Adding statement: <<nextTo[CONST:2, CONST:4]>>
Adding statement: <<nextTo[CONST:4, CONST:2]>>
Adding statement: <<nextTo[CONST:4, CONST:5]>>
Adding statement: <<nextTo[CONST:5, CONST:4]>>
Adding statement: <<directlyEastOf[CONST:1, CONST:2]>>
Adding statement: <<directlyEastOf[CONST:3, CONST:4]>>
Adding rule: <<[house[VAR:X], house[VAR:Y], (VAR:X > VAR:Y)] => northOf[VAR:X, VAR:Y]>>
Adding rule: <<[house[VAR:X], house[VAR:Y], (VAR:X < VAR:Y)] => southOf[VAR:X, VAR:Y]>>
---------
Begin find solutions on statement: <<hint1[VAR:H3, VAR:W1, VAR:H2, VAR:H1]>>

Matches statement? false

Applying rules for <<hint1[VAR:H3, VAR:W1, VAR:H2, VAR:H1]>>

proving antecedent : <<hairOf[VAR:W1, CONST:blonde]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairOf[VAR:W1, CONST:blonde]>>

statement : <<hairOf[VAR:W1, CONST:blonde]>> matched <<hairOf[CONST:adele, CONST:blonde]>>
added solution for <<hairOf[VAR:W1, CONST:blonde]>> : solution: <<SOLUTION: [(VAR:W1=CONST:adele)]>>
statement : <<hairOf[VAR:W1, CONST:blonde]>> matched <<hairOf[CONST:jane, CONST:blonde]>>
added solution for <<hairOf[VAR:W1, CONST:blonde]>> : solution: <<SOLUTION: [(VAR:W1=CONST:jane)]>>
statement : <<hairOf[VAR:W1, CONST:blonde]>> matched <<hairOf[CONST:laura, CONST:blonde]>>
added solution for <<hairOf[VAR:W1, CONST:blonde]>> : solution: <<SOLUTION: [(VAR:W1=CONST:laura)]>>
statement : <<hairOf[VAR:W1, CONST:blonde]>> matched <<hairOf[CONST:molly, CONST:blonde]>>
added solution for <<hairOf[VAR:W1, CONST:blonde]>> : solution: <<SOLUTION: [(VAR:W1=CONST:molly)]>>
statement : <<hairOf[VAR:W1, CONST:blonde]>> matched <<hairOf[CONST:sarah, CONST:blonde]>>
added solution for <<hairOf[VAR:W1, CONST:blonde]>> : solution: <<SOLUTION: [(VAR:W1=CONST:sarah)]>>
Matches statement? true
proving antecedent : <<houseOf[VAR:W1, VAR:H1]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah)]
>> with replacements <<[(VAR:H3=VAR:H3), (VAR:W1=VAR:W1), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<houseOf[VAR:W1, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah)]>>
Fully unified: houseOf[CONST:sarah, VAR:H1]
---------
Begin find solutions on statement: <<houseOf[CONST:sarah, VAR:H1]>>

statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:1]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W1, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly)]>>
Fully unified: houseOf[CONST:molly, VAR:H1]
---------
Begin find solutions on statement: <<houseOf[CONST:molly, VAR:H1]>>

statement : <<houseOf[CONST:molly, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:1]>>
added solution for <<houseOf[CONST:molly, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
statement : <<houseOf[CONST:molly, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[CONST:molly, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
statement : <<houseOf[CONST:molly, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[CONST:molly, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
statement : <<houseOf[CONST:molly, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[CONST:molly, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
statement : <<houseOf[CONST:molly, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[CONST:molly, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W1, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura)]>>
Fully unified: houseOf[CONST:laura, VAR:H1]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, VAR:H1]>>

statement : <<houseOf[CONST:laura, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:1]>>
added solution for <<houseOf[CONST:laura, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
statement : <<houseOf[CONST:laura, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[CONST:laura, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
statement : <<houseOf[CONST:laura, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[CONST:laura, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
statement : <<houseOf[CONST:laura, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[CONST:laura, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
statement : <<houseOf[CONST:laura, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[CONST:laura, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W1, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane)]>>
Fully unified: houseOf[CONST:jane, VAR:H1]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, VAR:H1]>>

statement : <<houseOf[CONST:jane, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:1]>>
added solution for <<houseOf[CONST:jane, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
statement : <<houseOf[CONST:jane, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[CONST:jane, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
statement : <<houseOf[CONST:jane, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[CONST:jane, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
statement : <<houseOf[CONST:jane, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[CONST:jane, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
statement : <<houseOf[CONST:jane, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[CONST:jane, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W1, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele)]>>
Fully unified: houseOf[CONST:adele, VAR:H1]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, VAR:H1]>>

statement : <<houseOf[CONST:adele, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:1]>>
added solution for <<houseOf[CONST:adele, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
statement : <<houseOf[CONST:adele, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[CONST:adele, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
statement : <<houseOf[CONST:adele, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[CONST:adele, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
statement : <<houseOf[CONST:adele, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[CONST:adele, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
statement : <<houseOf[CONST:adele, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[CONST:adele, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]

proving antecedent : <<nextTo[VAR:H2, VAR:H1]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]
>> with replacements <<[(VAR:H3=VAR:H3), (VAR:W1=VAR:W1), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:5]>>

statement : <<nextTo[VAR:H2, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H2, CONST:5]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:4]>>

statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:3]>>

statement : <<nextTo[VAR:H2, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H2, CONST:3]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:2]>>

statement : <<nextTo[VAR:H2, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:1]>>

statement : <<nextTo[VAR:H2, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H2, CONST:1]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:5]>>

statement : <<nextTo[VAR:H2, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H2, CONST:5]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:4]>>

statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:3]>>

statement : <<nextTo[VAR:H2, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H2, CONST:3]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:2]>>

statement : <<nextTo[VAR:H2, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:1]>>

statement : <<nextTo[VAR:H2, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H2, CONST:1]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:5]>>

statement : <<nextTo[VAR:H2, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H2, CONST:5]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:4]>>

statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:3]>>

statement : <<nextTo[VAR:H2, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H2, CONST:3]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:2]>>

statement : <<nextTo[VAR:H2, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:1]>>

statement : <<nextTo[VAR:H2, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H2, CONST:1]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:5]>>

statement : <<nextTo[VAR:H2, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H2, CONST:5]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:4]>>

statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:3]>>

statement : <<nextTo[VAR:H2, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H2, CONST:3]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:2]>>

statement : <<nextTo[VAR:H2, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:1]>>

statement : <<nextTo[VAR:H2, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H2, CONST:1]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:5]>>

statement : <<nextTo[VAR:H2, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H2, CONST:5]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:4]>>

statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:3]>>

statement : <<nextTo[VAR:H2, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H2, CONST:3]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:2]>>

statement : <<nextTo[VAR:H2, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:1]>>

statement : <<nextTo[VAR:H2, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H2, CONST:1]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]

proving antecedent : <<southOf[VAR:H2, VAR:H1]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
>> with replacements <<[(VAR:H3=VAR:H3), (VAR:W1=VAR:W1), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

proving antecedent : <<houseOf[CONST:adele, VAR:H2]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
>> with replacements <<[(VAR:H3=VAR:H3), (VAR:W1=VAR:W1), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: houseOf[CONST:adele, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:1]>>

statement : <<houseOf[CONST:adele, CONST:1]>> matched <<houseOf[CONST:adele, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: houseOf[CONST:adele, CONST:2]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:2]>>

statement : <<houseOf[CONST:adele, CONST:2]>> matched <<houseOf[CONST:adele, CONST:2]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: houseOf[CONST:adele, CONST:4]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:4]>>

statement : <<houseOf[CONST:adele, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: houseOf[CONST:adele, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:1]>>

statement : <<houseOf[CONST:adele, CONST:1]>> matched <<houseOf[CONST:adele, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: houseOf[CONST:adele, CONST:2]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:2]>>

statement : <<houseOf[CONST:adele, CONST:2]>> matched <<houseOf[CONST:adele, CONST:2]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: houseOf[CONST:adele, CONST:4]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:4]>>

statement : <<houseOf[CONST:adele, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: houseOf[CONST:adele, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:1]>>

statement : <<houseOf[CONST:adele, CONST:1]>> matched <<houseOf[CONST:adele, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: houseOf[CONST:adele, CONST:2]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:2]>>

statement : <<houseOf[CONST:adele, CONST:2]>> matched <<houseOf[CONST:adele, CONST:2]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: houseOf[CONST:adele, CONST:4]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:4]>>

statement : <<houseOf[CONST:adele, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: houseOf[CONST:adele, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:1]>>

statement : <<houseOf[CONST:adele, CONST:1]>> matched <<houseOf[CONST:adele, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: houseOf[CONST:adele, CONST:2]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:2]>>

statement : <<houseOf[CONST:adele, CONST:2]>> matched <<houseOf[CONST:adele, CONST:2]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: houseOf[CONST:adele, CONST:4]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:4]>>

statement : <<houseOf[CONST:adele, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: houseOf[CONST:adele, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:1]>>

statement : <<houseOf[CONST:adele, CONST:1]>> matched <<houseOf[CONST:adele, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: houseOf[CONST:adele, CONST:2]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:2]>>

statement : <<houseOf[CONST:adele, CONST:2]>> matched <<houseOf[CONST:adele, CONST:2]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: houseOf[CONST:adele, CONST:4]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, CONST:4]>>

statement : <<houseOf[CONST:adele, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
Matches statement? true
proving antecedent : <<directlyEastOf[VAR:H3, VAR:H2]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
>> with replacements <<[(VAR:H3=VAR:H3), (VAR:W1=VAR:W1), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H3, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:2]>>

statement : <<directlyEastOf[VAR:H3, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H3, CONST:2]>> : solution: <<SOLUTION: [(VAR:H3=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:4]>>

statement : <<directlyEastOf[VAR:H3, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H3, CONST:4]>> : solution: <<SOLUTION: [(VAR:H3=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H3, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:2]>>

statement : <<directlyEastOf[VAR:H3, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H3, CONST:2]>> : solution: <<SOLUTION: [(VAR:H3=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:4]>>

statement : <<directlyEastOf[VAR:H3, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H3, CONST:4]>> : solution: <<SOLUTION: [(VAR:H3=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H3, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:2]>>

statement : <<directlyEastOf[VAR:H3, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H3, CONST:2]>> : solution: <<SOLUTION: [(VAR:H3=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:4]>>

statement : <<directlyEastOf[VAR:H3, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H3, CONST:4]>> : solution: <<SOLUTION: [(VAR:H3=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H3, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:2]>>

statement : <<directlyEastOf[VAR:H3, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H3, CONST:2]>> : solution: <<SOLUTION: [(VAR:H3=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:4]>>

statement : <<directlyEastOf[VAR:H3, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H3, CONST:4]>> : solution: <<SOLUTION: [(VAR:H3=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H3, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:2]>>

statement : <<directlyEastOf[VAR:H3, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H3, CONST:2]>> : solution: <<SOLUTION: [(VAR:H3=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H3, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H3, CONST:4]>>

statement : <<directlyEastOf[VAR:H3, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H3, CONST:4]>> : solution: <<SOLUTION: [(VAR:H3=CONST:3)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]

proving antecedent : <<houseOf[CONST:laura, VAR:H3]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
>> with replacements <<[(VAR:H3=VAR:H3), (VAR:W1=VAR:W1), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]>>
Fully unified: houseOf[CONST:laura, CONST:3]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, CONST:3]>>

statement : <<houseOf[CONST:laura, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]>>
Fully unified: houseOf[CONST:laura, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, CONST:1]>>

statement : <<houseOf[CONST:laura, CONST:1]>> matched <<houseOf[CONST:laura, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]>>
Fully unified: houseOf[CONST:laura, CONST:3]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, CONST:3]>>

statement : <<houseOf[CONST:laura, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]>>
Fully unified: houseOf[CONST:laura, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, CONST:1]>>

statement : <<houseOf[CONST:laura, CONST:1]>> matched <<houseOf[CONST:laura, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]>>
Fully unified: houseOf[CONST:laura, CONST:3]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, CONST:3]>>

statement : <<houseOf[CONST:laura, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]>>
Fully unified: houseOf[CONST:laura, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, CONST:1]>>

statement : <<houseOf[CONST:laura, CONST:1]>> matched <<houseOf[CONST:laura, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]>>
Fully unified: houseOf[CONST:laura, CONST:3]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, CONST:3]>>

statement : <<houseOf[CONST:laura, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]>>
Fully unified: houseOf[CONST:laura, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, CONST:1]>>

statement : <<houseOf[CONST:laura, CONST:1]>> matched <<houseOf[CONST:laura, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]>>
Fully unified: houseOf[CONST:laura, CONST:3]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, CONST:3]>>

statement : <<houseOf[CONST:laura, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]>>
Fully unified: houseOf[CONST:laura, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, CONST:1]>>

statement : <<houseOf[CONST:laura, CONST:1]>> matched <<houseOf[CONST:laura, CONST:1]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hint1[VAR:H3, VAR:W1, VAR:H2, VAR:H1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2), (VAR:H3=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4), (VAR:H3=CONST:3)]
>>

---------
Begin find solutions on statement: <<hint2[VAR:H2, VAR:H1]>>

Matches statement? false

Applying rules for <<hint2[VAR:H2, VAR:H1]>>

proving antecedent : <<houseOf[CONST:sarah, VAR:H1]>>

Adding initial solutions
---------
Begin find solutions on statement: <<houseOf[CONST:sarah, VAR:H1]>>

statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:1]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Matches statement? true
proving antecedent : <<nextTo[VAR:H2, VAR:H1]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H1=CONST:1)]
SOLUTION: [(VAR:H1=CONST:2)]
SOLUTION: [(VAR:H1=CONST:3)]
SOLUTION: [(VAR:H1=CONST:4)]
SOLUTION: [(VAR:H1=CONST:5)]
>> with replacements <<[(VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Fully unified: nextTo[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:5]>>

statement : <<nextTo[VAR:H2, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H2, CONST:5]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
Fully unified: nextTo[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:4]>>

statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
Fully unified: nextTo[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:3]>>

statement : <<nextTo[VAR:H2, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H2, CONST:3]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
Fully unified: nextTo[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:2]>>

statement : <<nextTo[VAR:H2, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
Fully unified: nextTo[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:1]>>

statement : <<nextTo[VAR:H2, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H2, CONST:1]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:H1=CONST:1), (VAR:H2=CONST:3)]

proving antecedent : <<southOf[VAR:H2, VAR:H1]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:H1=CONST:1), (VAR:H2=CONST:3)]
>> with replacements <<[(VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: southOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<southOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<southOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 < CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 < CONST:1)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:3, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:2)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:4, CONST:2]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: southOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<southOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<southOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 < CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 < CONST:3)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:1, CONST:3]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: southOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 < CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<southOf[CONST:5, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: southOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<southOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<southOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 < CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 < CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:2, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<southOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: southOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<southOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<southOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X < VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 < CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 < CONST:5)
evaluated to true
at least one rule succeeded? true
final solution for statement <<southOf[CONST:4, CONST:5]>> : <<QUERY true, SOLUTIONS: >>

proving antecedent : <<houseOf[CONST:molly, VAR:H2]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:H1=CONST:3), (VAR:H2=CONST:1)]
>> with replacements <<[(VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<houseOf[CONST:molly, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: houseOf[CONST:molly, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:molly, CONST:1]>>

statement : <<houseOf[CONST:molly, CONST:1]>> matched <<houseOf[CONST:molly, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:molly, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: houseOf[CONST:molly, CONST:2]
---------
Begin find solutions on statement: <<houseOf[CONST:molly, CONST:2]>>

statement : <<houseOf[CONST:molly, CONST:2]>> matched <<houseOf[CONST:molly, CONST:2]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:molly, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: houseOf[CONST:molly, CONST:4]
---------
Begin find solutions on statement: <<houseOf[CONST:molly, CONST:4]>>

statement : <<houseOf[CONST:molly, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hint2[VAR:H2, VAR:H1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:H1=CONST:3), (VAR:H2=CONST:1)]
>>

---------
Begin find solutions on statement: <<hint3[VAR:H3, VAR:W1, VAR:W2, VAR:H2, VAR:H1]>>

Matches statement? false

Applying rules for <<hint3[VAR:H3, VAR:W1, VAR:W2, VAR:H2, VAR:H1]>>

proving antecedent : <<houseOf[VAR:W1, VAR:H1]>>

Adding initial solutions
---------
Begin find solutions on statement: <<houseOf[VAR:W1, VAR:H1]>>

statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:1]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:1]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:1]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:1]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:1]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]>>
statement : <<houseOf[VAR:W1, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W1, VAR:H1]>> : solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]>>
Matches statement? true
proving antecedent : <<directlyEastOf[VAR:H2, VAR:H1]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]
>> with replacements <<[(VAR:H3=VAR:H3), (VAR:W1=VAR:W1), (VAR:W2=VAR:W2), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:5]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:5]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:4]>>

statement : <<directlyEastOf[VAR:H2, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:3]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:3]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:2]>>

statement : <<directlyEastOf[VAR:H2, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:5]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:5]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:4]>>

statement : <<directlyEastOf[VAR:H2, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:3]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:3]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:2]>>

statement : <<directlyEastOf[VAR:H2, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:5]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:5]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:4]>>

statement : <<directlyEastOf[VAR:H2, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:3]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:3]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:2]>>

statement : <<directlyEastOf[VAR:H2, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:5]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:5]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:4]>>

statement : <<directlyEastOf[VAR:H2, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:3]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:3]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:2]>>

statement : <<directlyEastOf[VAR:H2, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:5]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:5]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:4]>>

statement : <<directlyEastOf[VAR:H2, CONST:4]>> matched <<directlyEastOf[CONST:3, CONST:4]>>
added solution for <<directlyEastOf[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:3]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:3]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:2]>>

statement : <<directlyEastOf[VAR:H2, CONST:2]>> matched <<directlyEastOf[CONST:1, CONST:2]>>
added solution for <<directlyEastOf[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<directlyEastOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]>>
Fully unified: directlyEastOf[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<directlyEastOf[VAR:H2, CONST:1]>>

Matches statement? false

Applying rules for <<directlyEastOf[VAR:H2, CONST:1]>>

at least one rule succeeded? false
final solution for statement <<directlyEastOf[VAR:H2, CONST:1]>> : <<QUERY false, SOLUTIONS: >>

expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]

proving antecedent : <<houseOf[CONST:jane, VAR:H2]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
>> with replacements <<[(VAR:H3=VAR:H3), (VAR:W1=VAR:W1), (VAR:W2=VAR:W2), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]>>
Fully unified: houseOf[CONST:jane, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, CONST:1]>>

statement : <<houseOf[CONST:jane, CONST:1]>> matched <<houseOf[CONST:jane, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]>>
Fully unified: houseOf[CONST:jane, CONST:3]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, CONST:3]>>

statement : <<houseOf[CONST:jane, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]>>
Fully unified: houseOf[CONST:jane, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, CONST:1]>>

statement : <<houseOf[CONST:jane, CONST:1]>> matched <<houseOf[CONST:jane, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]>>
Fully unified: houseOf[CONST:jane, CONST:3]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, CONST:3]>>

statement : <<houseOf[CONST:jane, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]>>
Fully unified: houseOf[CONST:jane, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, CONST:1]>>

statement : <<houseOf[CONST:jane, CONST:1]>> matched <<houseOf[CONST:jane, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]>>
Fully unified: houseOf[CONST:jane, CONST:3]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, CONST:3]>>

statement : <<houseOf[CONST:jane, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]>>
Fully unified: houseOf[CONST:jane, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, CONST:1]>>

statement : <<houseOf[CONST:jane, CONST:1]>> matched <<houseOf[CONST:jane, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]>>
Fully unified: houseOf[CONST:jane, CONST:3]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, CONST:3]>>

statement : <<houseOf[CONST:jane, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]>>
Fully unified: houseOf[CONST:jane, CONST:1]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, CONST:1]>>

statement : <<houseOf[CONST:jane, CONST:1]>> matched <<houseOf[CONST:jane, CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]>>
Fully unified: houseOf[CONST:jane, CONST:3]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, CONST:3]>>

statement : <<houseOf[CONST:jane, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
Matches statement? true
proving antecedent : <<northOf[VAR:H3, VAR:H2]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]
>> with replacements <<[(VAR:H3=VAR:H3), (VAR:W1=VAR:W1), (VAR:W2=VAR:W2), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<northOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]>>
Fully unified: northOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<northOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[VAR:H3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:1)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H3, CONST:1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H3=CONST:2)]
SOLUTION: [(VAR:H3=CONST:3)]
SOLUTION: [(VAR:H3=CONST:4)]
SOLUTION: [(VAR:H3=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]>>
Fully unified: northOf[VAR:H3, CONST:3]
---------
Begin find solutions on statement: <<northOf[VAR:H3, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[VAR:H3, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H3, CONST:3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H3=CONST:4)]
SOLUTION: [(VAR:H3=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]>>
Fully unified: northOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<northOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[VAR:H3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:1)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H3, CONST:1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H3=CONST:2)]
SOLUTION: [(VAR:H3=CONST:3)]
SOLUTION: [(VAR:H3=CONST:4)]
SOLUTION: [(VAR:H3=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]>>
Fully unified: northOf[VAR:H3, CONST:3]
---------
Begin find solutions on statement: <<northOf[VAR:H3, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[VAR:H3, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H3, CONST:3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H3=CONST:4)]
SOLUTION: [(VAR:H3=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]>>
Fully unified: northOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<northOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[VAR:H3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:1)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H3, CONST:1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H3=CONST:2)]
SOLUTION: [(VAR:H3=CONST:3)]
SOLUTION: [(VAR:H3=CONST:4)]
SOLUTION: [(VAR:H3=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]>>
Fully unified: northOf[VAR:H3, CONST:3]
---------
Begin find solutions on statement: <<northOf[VAR:H3, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[VAR:H3, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H3, CONST:3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H3=CONST:4)]
SOLUTION: [(VAR:H3=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]>>
Fully unified: northOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<northOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[VAR:H3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:1)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H3, CONST:1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H3=CONST:2)]
SOLUTION: [(VAR:H3=CONST:3)]
SOLUTION: [(VAR:H3=CONST:4)]
SOLUTION: [(VAR:H3=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]>>
Fully unified: northOf[VAR:H3, CONST:3]
---------
Begin find solutions on statement: <<northOf[VAR:H3, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[VAR:H3, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H3, CONST:3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H3=CONST:4)]
SOLUTION: [(VAR:H3=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1)]>>
Fully unified: northOf[VAR:H3, CONST:1]
---------
Begin find solutions on statement: <<northOf[VAR:H3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[VAR:H3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:1]
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:1)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:1)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:1)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:1)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H3, CONST:1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H3=CONST:2)]
SOLUTION: [(VAR:H3=CONST:3)]
SOLUTION: [(VAR:H3=CONST:4)]
SOLUTION: [(VAR:H3=CONST:5)]
>>

current statement to prove while expanding: <<northOf[VAR:H3, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3)]>>
Fully unified: northOf[VAR:H3, CONST:3]
---------
Begin find solutions on statement: <<northOf[VAR:H3, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[VAR:H3, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[VAR:X]>>

statement : <<house[VAR:X]>> matched <<house[CONST:1]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:2]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:3]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:4]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
statement : <<house[VAR:X]>> matched <<house[CONST:5]>>
added solution for <<house[VAR:X]>> : solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
current statement to prove while expanding: <<house[VAR:Y]>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: house[CONST:3]
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:X=CONST:1)]
SOLUTION: [(VAR:X=CONST:2)]
SOLUTION: [(VAR:X=CONST:3)]
SOLUTION: [(VAR:X=CONST:4)]
SOLUTION: [(VAR:X=CONST:5)]
>> with replacements <<[(VAR:X=VAR:X), (VAR:Y=CONST:3)]>>
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:5)]>>
Fully unified: (CONST:5 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:5 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:4)]>>
Fully unified: (CONST:4 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:4 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:3)
evaluated to true
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:3)]>>
Fully unified: (CONST:3 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:3 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:2)]>>
Fully unified: (CONST:2 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:2 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:3)
evaluated to false
current statement to prove while expanding: <<(VAR:X > VAR:Y)>>
Working on solution: <<SOLUTION: [(VAR:X=CONST:1)]>>
Fully unified: (CONST:1 > CONST:3)
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? true
final solution for statement <<northOf[VAR:H3, CONST:3]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:H3=CONST:4)]
SOLUTION: [(VAR:H3=CONST:5)]
>>

expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]

proving antecedent : <<houseOf[VAR:W2, VAR:H3]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]
>> with replacements <<[(VAR:H3=VAR:H3), (VAR:W1=VAR:W1), (VAR:W2=VAR:W2), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]>>
Fully unified: houseOf[VAR:W2, CONST:3]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:3]>>

statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]>>
Fully unified: houseOf[VAR:W2, CONST:2]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:2]>>

statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]>>
Fully unified: houseOf[VAR:W2, CONST:3]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:3]>>

statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]>>
Fully unified: houseOf[VAR:W2, CONST:2]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:2]>>

statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]>>
Fully unified: houseOf[VAR:W2, CONST:3]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:3]>>

statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]>>
Fully unified: houseOf[VAR:W2, CONST:2]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:2]>>

statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]>>
Fully unified: houseOf[VAR:W2, CONST:3]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:3]>>

statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]>>
Fully unified: houseOf[VAR:W2, CONST:2]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:2]>>

statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3)]>>
Fully unified: houseOf[VAR:W2, CONST:3]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:3]>>

statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H3]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2)]>>
Fully unified: houseOf[VAR:W2, CONST:2]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:2]>>

statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:2]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[VAR:W2, CONST:2]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]

proving antecedent : <<hairOf[VAR:W2, CONST:grey]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
>> with replacements <<[(VAR:H3=VAR:H3), (VAR:W1=VAR:W1), (VAR:W2=VAR:W2), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:grey]>>

statement : <<hairOf[CONST:sarah, CONST:grey]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:grey]>>

statement : <<hairOf[CONST:molly, CONST:grey]>> matched <<hairOf[CONST:molly, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:grey]>>

statement : <<hairOf[CONST:laura, CONST:grey]>> matched <<hairOf[CONST:laura, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:grey]>>

statement : <<hairOf[CONST:jane, CONST:grey]>> matched <<hairOf[CONST:jane, CONST:grey]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:grey]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:grey]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:grey]>>

statement : <<hairOf[CONST:adele, CONST:grey]>> matched <<hairOf[CONST:adele, CONST:grey]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hint3[VAR:H3, VAR:W1, VAR:W2, VAR:H2, VAR:H1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:3), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:1), (VAR:H3=CONST:2), (VAR:W2=CONST:sarah)]
>>

---------
Begin find solutions on statement: <<hint4[VAR:W1, VAR:W2, VAR:H2, VAR:H1]>>

Matches statement? false

Applying rules for <<hint4[VAR:W1, VAR:W2, VAR:H2, VAR:H1]>>

proving antecedent : <<hairOf[VAR:W1, CONST:chestnut]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairOf[VAR:W1, CONST:chestnut]>>

statement : <<hairOf[VAR:W1, CONST:chestnut]>> matched <<hairOf[CONST:adele, CONST:chestnut]>>
added solution for <<hairOf[VAR:W1, CONST:chestnut]>> : solution: <<SOLUTION: [(VAR:W1=CONST:adele)]>>
statement : <<hairOf[VAR:W1, CONST:chestnut]>> matched <<hairOf[CONST:jane, CONST:chestnut]>>
added solution for <<hairOf[VAR:W1, CONST:chestnut]>> : solution: <<SOLUTION: [(VAR:W1=CONST:jane)]>>
statement : <<hairOf[VAR:W1, CONST:chestnut]>> matched <<hairOf[CONST:laura, CONST:chestnut]>>
added solution for <<hairOf[VAR:W1, CONST:chestnut]>> : solution: <<SOLUTION: [(VAR:W1=CONST:laura)]>>
statement : <<hairOf[VAR:W1, CONST:chestnut]>> matched <<hairOf[CONST:molly, CONST:chestnut]>>
added solution for <<hairOf[VAR:W1, CONST:chestnut]>> : solution: <<SOLUTION: [(VAR:W1=CONST:molly)]>>
statement : <<hairOf[VAR:W1, CONST:chestnut]>> matched <<hairOf[CONST:sarah, CONST:chestnut]>>
added solution for <<hairOf[VAR:W1, CONST:chestnut]>> : solution: <<SOLUTION: [(VAR:W1=CONST:sarah)]>>
Matches statement? true
proving antecedent : <<houseOf[VAR:W1, VAR:H1]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah)]
>> with replacements <<[(VAR:W1=VAR:W1), (VAR:W2=VAR:W2), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<houseOf[VAR:W1, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah)]>>
Fully unified: houseOf[CONST:sarah, VAR:H1]
---------
Begin find solutions on statement: <<houseOf[CONST:sarah, VAR:H1]>>

statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:1]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
statement : <<houseOf[CONST:sarah, VAR:H1]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[CONST:sarah, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W1, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly)]>>
Fully unified: houseOf[CONST:molly, VAR:H1]
---------
Begin find solutions on statement: <<houseOf[CONST:molly, VAR:H1]>>

statement : <<houseOf[CONST:molly, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:1]>>
added solution for <<houseOf[CONST:molly, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
statement : <<houseOf[CONST:molly, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[CONST:molly, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
statement : <<houseOf[CONST:molly, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[CONST:molly, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
statement : <<houseOf[CONST:molly, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[CONST:molly, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
statement : <<houseOf[CONST:molly, VAR:H1]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[CONST:molly, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W1, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura)]>>
Fully unified: houseOf[CONST:laura, VAR:H1]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, VAR:H1]>>

statement : <<houseOf[CONST:laura, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:1]>>
added solution for <<houseOf[CONST:laura, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
statement : <<houseOf[CONST:laura, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[CONST:laura, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
statement : <<houseOf[CONST:laura, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[CONST:laura, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
statement : <<houseOf[CONST:laura, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[CONST:laura, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
statement : <<houseOf[CONST:laura, VAR:H1]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[CONST:laura, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W1, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane)]>>
Fully unified: houseOf[CONST:jane, VAR:H1]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, VAR:H1]>>

statement : <<houseOf[CONST:jane, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:1]>>
added solution for <<houseOf[CONST:jane, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
statement : <<houseOf[CONST:jane, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[CONST:jane, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
statement : <<houseOf[CONST:jane, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[CONST:jane, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
statement : <<houseOf[CONST:jane, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[CONST:jane, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
statement : <<houseOf[CONST:jane, VAR:H1]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[CONST:jane, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W1, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele)]>>
Fully unified: houseOf[CONST:adele, VAR:H1]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, VAR:H1]>>

statement : <<houseOf[CONST:adele, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:1]>>
added solution for <<houseOf[CONST:adele, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:1)]>>
statement : <<houseOf[CONST:adele, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[CONST:adele, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:2)]>>
statement : <<houseOf[CONST:adele, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[CONST:adele, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:3)]>>
statement : <<houseOf[CONST:adele, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[CONST:adele, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:4)]>>
statement : <<houseOf[CONST:adele, VAR:H1]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[CONST:adele, VAR:H1]>> : solution: <<SOLUTION: [(VAR:H1=CONST:5)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]

proving antecedent : <<nextTo[VAR:H2, VAR:H1]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]
>> with replacements <<[(VAR:W1=VAR:W1), (VAR:W2=VAR:W2), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:5]>>

statement : <<nextTo[VAR:H2, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H2, CONST:5]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:4]>>

statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:3]>>

statement : <<nextTo[VAR:H2, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H2, CONST:3]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:2]>>

statement : <<nextTo[VAR:H2, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:1]>>

statement : <<nextTo[VAR:H2, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H2, CONST:1]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:5]>>

statement : <<nextTo[VAR:H2, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H2, CONST:5]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:4]>>

statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:3]>>

statement : <<nextTo[VAR:H2, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H2, CONST:3]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:2]>>

statement : <<nextTo[VAR:H2, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:1]>>

statement : <<nextTo[VAR:H2, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H2, CONST:1]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:5]>>

statement : <<nextTo[VAR:H2, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H2, CONST:5]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:4]>>

statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:3]>>

statement : <<nextTo[VAR:H2, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H2, CONST:3]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:2]>>

statement : <<nextTo[VAR:H2, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:1]>>

statement : <<nextTo[VAR:H2, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H2, CONST:1]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:5]>>

statement : <<nextTo[VAR:H2, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H2, CONST:5]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:4]>>

statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:3]>>

statement : <<nextTo[VAR:H2, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H2, CONST:3]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:2]>>

statement : <<nextTo[VAR:H2, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:1]>>

statement : <<nextTo[VAR:H2, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H2, CONST:1]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5)]>>
Fully unified: nextTo[VAR:H2, CONST:5]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:5]>>

statement : <<nextTo[VAR:H2, CONST:5]>> matched <<nextTo[CONST:4, CONST:5]>>
added solution for <<nextTo[VAR:H2, CONST:5]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4)]>>
Fully unified: nextTo[VAR:H2, CONST:4]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:4]>>

statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:2, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:2)]>>
statement : <<nextTo[VAR:H2, CONST:4]>> matched <<nextTo[CONST:5, CONST:4]>>
added solution for <<nextTo[VAR:H2, CONST:4]>> : solution: <<SOLUTION: [(VAR:H2=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3)]>>
Fully unified: nextTo[VAR:H2, CONST:3]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:3]>>

statement : <<nextTo[VAR:H2, CONST:3]>> matched <<nextTo[CONST:1, CONST:3]>>
added solution for <<nextTo[VAR:H2, CONST:3]>> : solution: <<SOLUTION: [(VAR:H2=CONST:1)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2)]>>
Fully unified: nextTo[VAR:H2, CONST:2]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:2]>>

statement : <<nextTo[VAR:H2, CONST:2]>> matched <<nextTo[CONST:4, CONST:2]>>
added solution for <<nextTo[VAR:H2, CONST:2]>> : solution: <<SOLUTION: [(VAR:H2=CONST:4)]>>
Matches statement? true
current statement to prove while expanding: <<nextTo[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1)]>>
Fully unified: nextTo[VAR:H2, CONST:1]
---------
Begin find solutions on statement: <<nextTo[VAR:H2, CONST:1]>>

statement : <<nextTo[VAR:H2, CONST:1]>> matched <<nextTo[CONST:3, CONST:1]>>
added solution for <<nextTo[VAR:H2, CONST:1]>> : solution: <<SOLUTION: [(VAR:H2=CONST:3)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]

proving antecedent : <<northOf[VAR:H2, VAR:H1]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
>> with replacements <<[(VAR:W1=VAR:W1), (VAR:W2=VAR:W2), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: northOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<northOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:3, CONST:1]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:2)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:4, CONST:2]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: northOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<northOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:1, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: northOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:5, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: northOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:2, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:5)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:4, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: northOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<northOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:3, CONST:1]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:2)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:4, CONST:2]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: northOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<northOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:1, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: northOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:5, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: northOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:2, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:5)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:4, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: northOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<northOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:3, CONST:1]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:2)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:4, CONST:2]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: northOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<northOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:1, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: northOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:5, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: northOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:2, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:5)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:4, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: northOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<northOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:3, CONST:1]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:2)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:4, CONST:2]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: northOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<northOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:1, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: northOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:5, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: northOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:2, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:5)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:4, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: northOf[CONST:3, CONST:1]
---------
Begin find solutions on statement: <<northOf[CONST:3, CONST:1]>>

Matches statement? false

Applying rules for <<northOf[CONST:3, CONST:1]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:3 > CONST:1)>>

Matches statement? false
evaluating statement: (CONST:3 > CONST:1)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:3, CONST:1]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:2]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:2]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:2]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:2)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:2)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:4, CONST:2]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:3), (VAR:H2=CONST:1)]>>
Fully unified: northOf[CONST:1, CONST:3]
---------
Begin find solutions on statement: <<northOf[CONST:1, CONST:3]>>

Matches statement? false

Applying rules for <<northOf[CONST:1, CONST:3]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:1]>>

statement : <<house[CONST:1]>> matched <<house[CONST:1]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:3]>>

statement : <<house[CONST:3]>> matched <<house[CONST:3]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:1 > CONST:3)>>

Matches statement? false
evaluating statement: (CONST:1 > CONST:3)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:1, CONST:3]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: northOf[CONST:5, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:5, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:5, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:5 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:5 > CONST:4)
evaluated to true
at least one rule succeeded? true
final solution for statement <<northOf[CONST:5, CONST:4]>> : <<QUERY true, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:2)]>>
Fully unified: northOf[CONST:2, CONST:4]
---------
Begin find solutions on statement: <<northOf[CONST:2, CONST:4]>>

Matches statement? false

Applying rules for <<northOf[CONST:2, CONST:4]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:2]>>

statement : <<house[CONST:2]>> matched <<house[CONST:2]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:2 > CONST:4)>>

Matches statement? false
evaluating statement: (CONST:2 > CONST:4)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:2, CONST:4]>> : <<QUERY false, SOLUTIONS: >>

current statement to prove while expanding: <<northOf[VAR:H2, VAR:H1]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:5), (VAR:H2=CONST:4)]>>
Fully unified: northOf[CONST:4, CONST:5]
---------
Begin find solutions on statement: <<northOf[CONST:4, CONST:5]>>

Matches statement? false

Applying rules for <<northOf[CONST:4, CONST:5]>>

proving antecedent : <<house[VAR:X]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:4]>>

statement : <<house[CONST:4]>> matched <<house[CONST:4]>>
Matches statement? true
proving antecedent : <<house[VAR:Y]>>

Adding initial solutions
---------
Begin find solutions on statement: <<house[CONST:5]>>

statement : <<house[CONST:5]>> matched <<house[CONST:5]>>
Matches statement? true
proving antecedent : <<(VAR:X > VAR:Y)>>

Adding initial solutions
---------
Begin find solutions on statement: <<(CONST:4 > CONST:5)>>

Matches statement? false
evaluating statement: (CONST:4 > CONST:5)
evaluated to false
at least one rule succeeded? false
final solution for statement <<northOf[CONST:4, CONST:5]>> : <<QUERY false, SOLUTIONS: >>

proving antecedent : <<houseOf[VAR:W2, VAR:H2]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]
>> with replacements <<[(VAR:W1=VAR:W1), (VAR:W2=VAR:W2), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: houseOf[VAR:W2, CONST:3]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:3]>>

statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: houseOf[VAR:W2, CONST:3]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:3]>>

statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: houseOf[VAR:W2, CONST:3]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:3]>>

statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: houseOf[VAR:W2, CONST:3]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:3]>>

statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3)]>>
Fully unified: houseOf[VAR:W2, CONST:3]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:3]>>

statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:3]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[VAR:W2, CONST:3]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4)]>>
Fully unified: houseOf[VAR:W2, CONST:4]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:4]>>

statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:4]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[VAR:W2, CONST:4]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[VAR:W2, VAR:H2]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5)]>>
Fully unified: houseOf[VAR:W2, CONST:5]
---------
Begin find solutions on statement: <<houseOf[VAR:W2, CONST:5]>>

statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:adele)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:jane)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:laura)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:molly)]>>
statement : <<houseOf[VAR:W2, CONST:5]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[VAR:W2, CONST:5]>> : solution: <<SOLUTION: [(VAR:W2=CONST:sarah)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]

proving antecedent : <<hairOf[VAR:W2, CONST:black]>>

Expanding solution set <<QUERY false, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
>> with replacements <<[(VAR:W1=VAR:W1), (VAR:W2=VAR:W2), (VAR:H2=VAR:H2), (VAR:H1=VAR:H1)]>>
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]>>
Fully unified: hairOf[CONST:sarah, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, CONST:black]>>

statement : <<hairOf[CONST:sarah, CONST:black]>> matched <<hairOf[CONST:sarah, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]>>
Fully unified: hairOf[CONST:molly, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:molly, CONST:black]>>

statement : <<hairOf[CONST:molly, CONST:black]>> matched <<hairOf[CONST:molly, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]>>
Fully unified: hairOf[CONST:laura, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:laura, CONST:black]>>

statement : <<hairOf[CONST:laura, CONST:black]>> matched <<hairOf[CONST:laura, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]>>
Fully unified: hairOf[CONST:jane, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:jane, CONST:black]>>

statement : <<hairOf[CONST:jane, CONST:black]>> matched <<hairOf[CONST:jane, CONST:black]>>
Matches statement? true
current statement to prove while expanding: <<hairOf[VAR:W2, CONST:black]>>
Working on solution: <<SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]>>
Fully unified: hairOf[CONST:adele, CONST:black]
---------
Begin find solutions on statement: <<hairOf[CONST:adele, CONST:black]>>

statement : <<hairOf[CONST:adele, CONST:black]>> matched <<hairOf[CONST:adele, CONST:black]>>
Matches statement? true
at least one rule succeeded? true
final solution for statement <<hint4[VAR:W1, VAR:W2, VAR:H2, VAR:H1]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:sarah), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:molly), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:laura), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:jane), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:1), (VAR:H2=CONST:3), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:2), (VAR:H2=CONST:4), (VAR:W2=CONST:sarah)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:adele)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:jane)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:laura)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:molly)]
SOLUTION: [(VAR:W1=CONST:adele), (VAR:H1=CONST:4), (VAR:H2=CONST:5), (VAR:W2=CONST:sarah)]
>>

---------
Begin find solutions on statement: <<solution1[VAR:ADELEHAIR, VAR:ADELEHOUSE]>>

Matches statement? false

Applying rules for <<solution1[VAR:ADELEHAIR, VAR:ADELEHOUSE]>>

proving antecedent : <<hairOf[CONST:adele, VAR:ADELEHAIR]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairOf[CONST:adele, VAR:ADELEHAIR]>>

statement : <<hairOf[CONST:adele, VAR:ADELEHAIR]>> matched <<hairOf[CONST:adele, CONST:black]>>
added solution for <<hairOf[CONST:adele, VAR:ADELEHAIR]>> : solution: <<SOLUTION: [(VAR:ADELEHAIR=CONST:black)]>>
statement : <<hairOf[CONST:adele, VAR:ADELEHAIR]>> matched <<hairOf[CONST:adele, CONST:blonde]>>
added solution for <<hairOf[CONST:adele, VAR:ADELEHAIR]>> : solution: <<SOLUTION: [(VAR:ADELEHAIR=CONST:blonde)]>>
statement : <<hairOf[CONST:adele, VAR:ADELEHAIR]>> matched <<hairOf[CONST:adele, CONST:brown]>>
added solution for <<hairOf[CONST:adele, VAR:ADELEHAIR]>> : solution: <<SOLUTION: [(VAR:ADELEHAIR=CONST:brown)]>>
statement : <<hairOf[CONST:adele, VAR:ADELEHAIR]>> matched <<hairOf[CONST:adele, CONST:chestnut]>>
added solution for <<hairOf[CONST:adele, VAR:ADELEHAIR]>> : solution: <<SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut)]>>
statement : <<hairOf[CONST:adele, VAR:ADELEHAIR]>> matched <<hairOf[CONST:adele, CONST:grey]>>
added solution for <<hairOf[CONST:adele, VAR:ADELEHAIR]>> : solution: <<SOLUTION: [(VAR:ADELEHAIR=CONST:grey)]>>
Matches statement? true
proving antecedent : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:ADELEHAIR=CONST:black)]
SOLUTION: [(VAR:ADELEHAIR=CONST:blonde)]
SOLUTION: [(VAR:ADELEHAIR=CONST:brown)]
SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut)]
SOLUTION: [(VAR:ADELEHAIR=CONST:grey)]
>> with replacements <<[(VAR:ADELEHAIR=VAR:ADELEHAIR), (VAR:ADELEHOUSE=VAR:ADELEHOUSE)]>>
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:ADELEHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:ADELEHAIR=CONST:grey)]>>
Fully unified: houseOf[CONST:adele, VAR:ADELEHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, VAR:ADELEHOUSE]>>

statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:1]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:ADELEHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut)]>>
Fully unified: houseOf[CONST:adele, VAR:ADELEHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, VAR:ADELEHOUSE]>>

statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:1]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:ADELEHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:ADELEHAIR=CONST:brown)]>>
Fully unified: houseOf[CONST:adele, VAR:ADELEHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, VAR:ADELEHOUSE]>>

statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:1]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:ADELEHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:ADELEHAIR=CONST:blonde)]>>
Fully unified: houseOf[CONST:adele, VAR:ADELEHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, VAR:ADELEHOUSE]>>

statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:1]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:adele, VAR:ADELEHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:ADELEHAIR=CONST:black)]>>
Fully unified: houseOf[CONST:adele, VAR:ADELEHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:adele, VAR:ADELEHOUSE]>>

statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:1]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:2]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:3]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:4]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> matched <<houseOf[CONST:adele, CONST:5]>>
added solution for <<houseOf[CONST:adele, VAR:ADELEHOUSE]>> : solution: <<SOLUTION: [(VAR:ADELEHOUSE=CONST:5)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:ADELEHAIR=CONST:grey), (VAR:ADELEHOUSE=CONST:1)]
SOLUTION: [(VAR:ADELEHAIR=CONST:grey), (VAR:ADELEHOUSE=CONST:2)]
SOLUTION: [(VAR:ADELEHAIR=CONST:grey), (VAR:ADELEHOUSE=CONST:3)]
SOLUTION: [(VAR:ADELEHAIR=CONST:grey), (VAR:ADELEHOUSE=CONST:4)]
SOLUTION: [(VAR:ADELEHAIR=CONST:grey), (VAR:ADELEHOUSE=CONST:5)]
SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut), (VAR:ADELEHOUSE=CONST:1)]
SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut), (VAR:ADELEHOUSE=CONST:2)]
SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut), (VAR:ADELEHOUSE=CONST:3)]
SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut), (VAR:ADELEHOUSE=CONST:4)]
SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut), (VAR:ADELEHOUSE=CONST:5)]
SOLUTION: [(VAR:ADELEHAIR=CONST:brown), (VAR:ADELEHOUSE=CONST:1)]
SOLUTION: [(VAR:ADELEHAIR=CONST:brown), (VAR:ADELEHOUSE=CONST:2)]
SOLUTION: [(VAR:ADELEHAIR=CONST:brown), (VAR:ADELEHOUSE=CONST:3)]
SOLUTION: [(VAR:ADELEHAIR=CONST:brown), (VAR:ADELEHOUSE=CONST:4)]
SOLUTION: [(VAR:ADELEHAIR=CONST:brown), (VAR:ADELEHOUSE=CONST:5)]
SOLUTION: [(VAR:ADELEHAIR=CONST:blonde), (VAR:ADELEHOUSE=CONST:1)]
SOLUTION: [(VAR:ADELEHAIR=CONST:blonde), (VAR:ADELEHOUSE=CONST:2)]
SOLUTION: [(VAR:ADELEHAIR=CONST:blonde), (VAR:ADELEHOUSE=CONST:3)]
SOLUTION: [(VAR:ADELEHAIR=CONST:blonde), (VAR:ADELEHOUSE=CONST:4)]
SOLUTION: [(VAR:ADELEHAIR=CONST:blonde), (VAR:ADELEHOUSE=CONST:5)]
SOLUTION: [(VAR:ADELEHAIR=CONST:black), (VAR:ADELEHOUSE=CONST:1)]
SOLUTION: [(VAR:ADELEHAIR=CONST:black), (VAR:ADELEHOUSE=CONST:2)]
SOLUTION: [(VAR:ADELEHAIR=CONST:black), (VAR:ADELEHOUSE=CONST:3)]
SOLUTION: [(VAR:ADELEHAIR=CONST:black), (VAR:ADELEHOUSE=CONST:4)]
SOLUTION: [(VAR:ADELEHAIR=CONST:black), (VAR:ADELEHOUSE=CONST:5)]

at least one rule succeeded? true
final solution for statement <<solution1[VAR:ADELEHAIR, VAR:ADELEHOUSE]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:ADELEHAIR=CONST:grey), (VAR:ADELEHOUSE=CONST:1)]
SOLUTION: [(VAR:ADELEHAIR=CONST:grey), (VAR:ADELEHOUSE=CONST:2)]
SOLUTION: [(VAR:ADELEHAIR=CONST:grey), (VAR:ADELEHOUSE=CONST:3)]
SOLUTION: [(VAR:ADELEHAIR=CONST:grey), (VAR:ADELEHOUSE=CONST:4)]
SOLUTION: [(VAR:ADELEHAIR=CONST:grey), (VAR:ADELEHOUSE=CONST:5)]
SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut), (VAR:ADELEHOUSE=CONST:1)]
SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut), (VAR:ADELEHOUSE=CONST:2)]
SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut), (VAR:ADELEHOUSE=CONST:3)]
SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut), (VAR:ADELEHOUSE=CONST:4)]
SOLUTION: [(VAR:ADELEHAIR=CONST:chestnut), (VAR:ADELEHOUSE=CONST:5)]
SOLUTION: [(VAR:ADELEHAIR=CONST:brown), (VAR:ADELEHOUSE=CONST:1)]
SOLUTION: [(VAR:ADELEHAIR=CONST:brown), (VAR:ADELEHOUSE=CONST:2)]
SOLUTION: [(VAR:ADELEHAIR=CONST:brown), (VAR:ADELEHOUSE=CONST:3)]
SOLUTION: [(VAR:ADELEHAIR=CONST:brown), (VAR:ADELEHOUSE=CONST:4)]
SOLUTION: [(VAR:ADELEHAIR=CONST:brown), (VAR:ADELEHOUSE=CONST:5)]
SOLUTION: [(VAR:ADELEHAIR=CONST:blonde), (VAR:ADELEHOUSE=CONST:1)]
SOLUTION: [(VAR:ADELEHAIR=CONST:blonde), (VAR:ADELEHOUSE=CONST:2)]
SOLUTION: [(VAR:ADELEHAIR=CONST:blonde), (VAR:ADELEHOUSE=CONST:3)]
SOLUTION: [(VAR:ADELEHAIR=CONST:blonde), (VAR:ADELEHOUSE=CONST:4)]
SOLUTION: [(VAR:ADELEHAIR=CONST:blonde), (VAR:ADELEHOUSE=CONST:5)]
SOLUTION: [(VAR:ADELEHAIR=CONST:black), (VAR:ADELEHOUSE=CONST:1)]
SOLUTION: [(VAR:ADELEHAIR=CONST:black), (VAR:ADELEHOUSE=CONST:2)]
SOLUTION: [(VAR:ADELEHAIR=CONST:black), (VAR:ADELEHOUSE=CONST:3)]
SOLUTION: [(VAR:ADELEHAIR=CONST:black), (VAR:ADELEHOUSE=CONST:4)]
SOLUTION: [(VAR:ADELEHAIR=CONST:black), (VAR:ADELEHOUSE=CONST:5)]
>>

---------
Begin find solutions on statement: <<solution2[VAR:JANEHAIR, VAR:JANEHOUSE]>>

Matches statement? false

Applying rules for <<solution2[VAR:JANEHAIR, VAR:JANEHOUSE]>>

proving antecedent : <<hairOf[CONST:jane, VAR:JANEHAIR]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairOf[CONST:jane, VAR:JANEHAIR]>>

statement : <<hairOf[CONST:jane, VAR:JANEHAIR]>> matched <<hairOf[CONST:jane, CONST:black]>>
added solution for <<hairOf[CONST:jane, VAR:JANEHAIR]>> : solution: <<SOLUTION: [(VAR:JANEHAIR=CONST:black)]>>
statement : <<hairOf[CONST:jane, VAR:JANEHAIR]>> matched <<hairOf[CONST:jane, CONST:blonde]>>
added solution for <<hairOf[CONST:jane, VAR:JANEHAIR]>> : solution: <<SOLUTION: [(VAR:JANEHAIR=CONST:blonde)]>>
statement : <<hairOf[CONST:jane, VAR:JANEHAIR]>> matched <<hairOf[CONST:jane, CONST:brown]>>
added solution for <<hairOf[CONST:jane, VAR:JANEHAIR]>> : solution: <<SOLUTION: [(VAR:JANEHAIR=CONST:brown)]>>
statement : <<hairOf[CONST:jane, VAR:JANEHAIR]>> matched <<hairOf[CONST:jane, CONST:chestnut]>>
added solution for <<hairOf[CONST:jane, VAR:JANEHAIR]>> : solution: <<SOLUTION: [(VAR:JANEHAIR=CONST:chestnut)]>>
statement : <<hairOf[CONST:jane, VAR:JANEHAIR]>> matched <<hairOf[CONST:jane, CONST:grey]>>
added solution for <<hairOf[CONST:jane, VAR:JANEHAIR]>> : solution: <<SOLUTION: [(VAR:JANEHAIR=CONST:grey)]>>
Matches statement? true
proving antecedent : <<houseOf[CONST:jane, VAR:JANEHOUSE]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:JANEHAIR=CONST:black)]
SOLUTION: [(VAR:JANEHAIR=CONST:blonde)]
SOLUTION: [(VAR:JANEHAIR=CONST:brown)]
SOLUTION: [(VAR:JANEHAIR=CONST:chestnut)]
SOLUTION: [(VAR:JANEHAIR=CONST:grey)]
>> with replacements <<[(VAR:JANEHAIR=VAR:JANEHAIR), (VAR:JANEHOUSE=VAR:JANEHOUSE)]>>
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:JANEHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:JANEHAIR=CONST:grey)]>>
Fully unified: houseOf[CONST:jane, VAR:JANEHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, VAR:JANEHOUSE]>>

statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:1]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:JANEHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:JANEHAIR=CONST:chestnut)]>>
Fully unified: houseOf[CONST:jane, VAR:JANEHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, VAR:JANEHOUSE]>>

statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:1]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:JANEHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:JANEHAIR=CONST:brown)]>>
Fully unified: houseOf[CONST:jane, VAR:JANEHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, VAR:JANEHOUSE]>>

statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:1]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:JANEHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:JANEHAIR=CONST:blonde)]>>
Fully unified: houseOf[CONST:jane, VAR:JANEHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, VAR:JANEHOUSE]>>

statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:1]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:jane, VAR:JANEHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:JANEHAIR=CONST:black)]>>
Fully unified: houseOf[CONST:jane, VAR:JANEHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:jane, VAR:JANEHOUSE]>>

statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:1]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:2]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:3]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:4]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:jane, VAR:JANEHOUSE]>> matched <<houseOf[CONST:jane, CONST:5]>>
added solution for <<houseOf[CONST:jane, VAR:JANEHOUSE]>> : solution: <<SOLUTION: [(VAR:JANEHOUSE=CONST:5)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:JANEHAIR=CONST:grey), (VAR:JANEHOUSE=CONST:1)]
SOLUTION: [(VAR:JANEHAIR=CONST:grey), (VAR:JANEHOUSE=CONST:2)]
SOLUTION: [(VAR:JANEHAIR=CONST:grey), (VAR:JANEHOUSE=CONST:3)]
SOLUTION: [(VAR:JANEHAIR=CONST:grey), (VAR:JANEHOUSE=CONST:4)]
SOLUTION: [(VAR:JANEHAIR=CONST:grey), (VAR:JANEHOUSE=CONST:5)]
SOLUTION: [(VAR:JANEHAIR=CONST:chestnut), (VAR:JANEHOUSE=CONST:1)]
SOLUTION: [(VAR:JANEHAIR=CONST:chestnut), (VAR:JANEHOUSE=CONST:2)]
SOLUTION: [(VAR:JANEHAIR=CONST:chestnut), (VAR:JANEHOUSE=CONST:3)]
SOLUTION: [(VAR:JANEHAIR=CONST:chestnut), (VAR:JANEHOUSE=CONST:4)]
SOLUTION: [(VAR:JANEHAIR=CONST:chestnut), (VAR:JANEHOUSE=CONST:5)]
SOLUTION: [(VAR:JANEHAIR=CONST:brown), (VAR:JANEHOUSE=CONST:1)]
SOLUTION: [(VAR:JANEHAIR=CONST:brown), (VAR:JANEHOUSE=CONST:2)]
SOLUTION: [(VAR:JANEHAIR=CONST:brown), (VAR:JANEHOUSE=CONST:3)]
SOLUTION: [(VAR:JANEHAIR=CONST:brown), (VAR:JANEHOUSE=CONST:4)]
SOLUTION: [(VAR:JANEHAIR=CONST:brown), (VAR:JANEHOUSE=CONST:5)]
SOLUTION: [(VAR:JANEHAIR=CONST:blonde), (VAR:JANEHOUSE=CONST:1)]
SOLUTION: [(VAR:JANEHAIR=CONST:blonde), (VAR:JANEHOUSE=CONST:2)]
SOLUTION: [(VAR:JANEHAIR=CONST:blonde), (VAR:JANEHOUSE=CONST:3)]
SOLUTION: [(VAR:JANEHAIR=CONST:blonde), (VAR:JANEHOUSE=CONST:4)]
SOLUTION: [(VAR:JANEHAIR=CONST:blonde), (VAR:JANEHOUSE=CONST:5)]
SOLUTION: [(VAR:JANEHAIR=CONST:black), (VAR:JANEHOUSE=CONST:1)]
SOLUTION: [(VAR:JANEHAIR=CONST:black), (VAR:JANEHOUSE=CONST:2)]
SOLUTION: [(VAR:JANEHAIR=CONST:black), (VAR:JANEHOUSE=CONST:3)]
SOLUTION: [(VAR:JANEHAIR=CONST:black), (VAR:JANEHOUSE=CONST:4)]
SOLUTION: [(VAR:JANEHAIR=CONST:black), (VAR:JANEHOUSE=CONST:5)]

at least one rule succeeded? true
final solution for statement <<solution2[VAR:JANEHAIR, VAR:JANEHOUSE]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:JANEHAIR=CONST:grey), (VAR:JANEHOUSE=CONST:1)]
SOLUTION: [(VAR:JANEHAIR=CONST:grey), (VAR:JANEHOUSE=CONST:2)]
SOLUTION: [(VAR:JANEHAIR=CONST:grey), (VAR:JANEHOUSE=CONST:3)]
SOLUTION: [(VAR:JANEHAIR=CONST:grey), (VAR:JANEHOUSE=CONST:4)]
SOLUTION: [(VAR:JANEHAIR=CONST:grey), (VAR:JANEHOUSE=CONST:5)]
SOLUTION: [(VAR:JANEHAIR=CONST:chestnut), (VAR:JANEHOUSE=CONST:1)]
SOLUTION: [(VAR:JANEHAIR=CONST:chestnut), (VAR:JANEHOUSE=CONST:2)]
SOLUTION: [(VAR:JANEHAIR=CONST:chestnut), (VAR:JANEHOUSE=CONST:3)]
SOLUTION: [(VAR:JANEHAIR=CONST:chestnut), (VAR:JANEHOUSE=CONST:4)]
SOLUTION: [(VAR:JANEHAIR=CONST:chestnut), (VAR:JANEHOUSE=CONST:5)]
SOLUTION: [(VAR:JANEHAIR=CONST:brown), (VAR:JANEHOUSE=CONST:1)]
SOLUTION: [(VAR:JANEHAIR=CONST:brown), (VAR:JANEHOUSE=CONST:2)]
SOLUTION: [(VAR:JANEHAIR=CONST:brown), (VAR:JANEHOUSE=CONST:3)]
SOLUTION: [(VAR:JANEHAIR=CONST:brown), (VAR:JANEHOUSE=CONST:4)]
SOLUTION: [(VAR:JANEHAIR=CONST:brown), (VAR:JANEHOUSE=CONST:5)]
SOLUTION: [(VAR:JANEHAIR=CONST:blonde), (VAR:JANEHOUSE=CONST:1)]
SOLUTION: [(VAR:JANEHAIR=CONST:blonde), (VAR:JANEHOUSE=CONST:2)]
SOLUTION: [(VAR:JANEHAIR=CONST:blonde), (VAR:JANEHOUSE=CONST:3)]
SOLUTION: [(VAR:JANEHAIR=CONST:blonde), (VAR:JANEHOUSE=CONST:4)]
SOLUTION: [(VAR:JANEHAIR=CONST:blonde), (VAR:JANEHOUSE=CONST:5)]
SOLUTION: [(VAR:JANEHAIR=CONST:black), (VAR:JANEHOUSE=CONST:1)]
SOLUTION: [(VAR:JANEHAIR=CONST:black), (VAR:JANEHOUSE=CONST:2)]
SOLUTION: [(VAR:JANEHAIR=CONST:black), (VAR:JANEHOUSE=CONST:3)]
SOLUTION: [(VAR:JANEHAIR=CONST:black), (VAR:JANEHOUSE=CONST:4)]
SOLUTION: [(VAR:JANEHAIR=CONST:black), (VAR:JANEHOUSE=CONST:5)]
>>

---------
Begin find solutions on statement: <<solution3[VAR:LAURAHAIR, VAR:LAURAHOUSE]>>

Matches statement? false

Applying rules for <<solution3[VAR:LAURAHAIR, VAR:LAURAHOUSE]>>

proving antecedent : <<hairOf[CONST:laura, VAR:LAURAHAIR]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairOf[CONST:laura, VAR:LAURAHAIR]>>

statement : <<hairOf[CONST:laura, VAR:LAURAHAIR]>> matched <<hairOf[CONST:laura, CONST:black]>>
added solution for <<hairOf[CONST:laura, VAR:LAURAHAIR]>> : solution: <<SOLUTION: [(VAR:LAURAHAIR=CONST:black)]>>
statement : <<hairOf[CONST:laura, VAR:LAURAHAIR]>> matched <<hairOf[CONST:laura, CONST:blonde]>>
added solution for <<hairOf[CONST:laura, VAR:LAURAHAIR]>> : solution: <<SOLUTION: [(VAR:LAURAHAIR=CONST:blonde)]>>
statement : <<hairOf[CONST:laura, VAR:LAURAHAIR]>> matched <<hairOf[CONST:laura, CONST:brown]>>
added solution for <<hairOf[CONST:laura, VAR:LAURAHAIR]>> : solution: <<SOLUTION: [(VAR:LAURAHAIR=CONST:brown)]>>
statement : <<hairOf[CONST:laura, VAR:LAURAHAIR]>> matched <<hairOf[CONST:laura, CONST:chestnut]>>
added solution for <<hairOf[CONST:laura, VAR:LAURAHAIR]>> : solution: <<SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut)]>>
statement : <<hairOf[CONST:laura, VAR:LAURAHAIR]>> matched <<hairOf[CONST:laura, CONST:grey]>>
added solution for <<hairOf[CONST:laura, VAR:LAURAHAIR]>> : solution: <<SOLUTION: [(VAR:LAURAHAIR=CONST:grey)]>>
Matches statement? true
proving antecedent : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:LAURAHAIR=CONST:black)]
SOLUTION: [(VAR:LAURAHAIR=CONST:blonde)]
SOLUTION: [(VAR:LAURAHAIR=CONST:brown)]
SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut)]
SOLUTION: [(VAR:LAURAHAIR=CONST:grey)]
>> with replacements <<[(VAR:LAURAHAIR=VAR:LAURAHAIR), (VAR:LAURAHOUSE=VAR:LAURAHOUSE)]>>
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:LAURAHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:LAURAHAIR=CONST:grey)]>>
Fully unified: houseOf[CONST:laura, VAR:LAURAHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, VAR:LAURAHOUSE]>>

statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:1]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:LAURAHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut)]>>
Fully unified: houseOf[CONST:laura, VAR:LAURAHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, VAR:LAURAHOUSE]>>

statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:1]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:LAURAHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:LAURAHAIR=CONST:brown)]>>
Fully unified: houseOf[CONST:laura, VAR:LAURAHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, VAR:LAURAHOUSE]>>

statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:1]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:LAURAHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:LAURAHAIR=CONST:blonde)]>>
Fully unified: houseOf[CONST:laura, VAR:LAURAHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, VAR:LAURAHOUSE]>>

statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:1]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:laura, VAR:LAURAHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:LAURAHAIR=CONST:black)]>>
Fully unified: houseOf[CONST:laura, VAR:LAURAHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:laura, VAR:LAURAHOUSE]>>

statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:1]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:2]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:3]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:4]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> matched <<houseOf[CONST:laura, CONST:5]>>
added solution for <<houseOf[CONST:laura, VAR:LAURAHOUSE]>> : solution: <<SOLUTION: [(VAR:LAURAHOUSE=CONST:5)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:LAURAHAIR=CONST:grey), (VAR:LAURAHOUSE=CONST:1)]
SOLUTION: [(VAR:LAURAHAIR=CONST:grey), (VAR:LAURAHOUSE=CONST:2)]
SOLUTION: [(VAR:LAURAHAIR=CONST:grey), (VAR:LAURAHOUSE=CONST:3)]
SOLUTION: [(VAR:LAURAHAIR=CONST:grey), (VAR:LAURAHOUSE=CONST:4)]
SOLUTION: [(VAR:LAURAHAIR=CONST:grey), (VAR:LAURAHOUSE=CONST:5)]
SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut), (VAR:LAURAHOUSE=CONST:1)]
SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut), (VAR:LAURAHOUSE=CONST:2)]
SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut), (VAR:LAURAHOUSE=CONST:3)]
SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut), (VAR:LAURAHOUSE=CONST:4)]
SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut), (VAR:LAURAHOUSE=CONST:5)]
SOLUTION: [(VAR:LAURAHAIR=CONST:brown), (VAR:LAURAHOUSE=CONST:1)]
SOLUTION: [(VAR:LAURAHAIR=CONST:brown), (VAR:LAURAHOUSE=CONST:2)]
SOLUTION: [(VAR:LAURAHAIR=CONST:brown), (VAR:LAURAHOUSE=CONST:3)]
SOLUTION: [(VAR:LAURAHAIR=CONST:brown), (VAR:LAURAHOUSE=CONST:4)]
SOLUTION: [(VAR:LAURAHAIR=CONST:brown), (VAR:LAURAHOUSE=CONST:5)]
SOLUTION: [(VAR:LAURAHAIR=CONST:blonde), (VAR:LAURAHOUSE=CONST:1)]
SOLUTION: [(VAR:LAURAHAIR=CONST:blonde), (VAR:LAURAHOUSE=CONST:2)]
SOLUTION: [(VAR:LAURAHAIR=CONST:blonde), (VAR:LAURAHOUSE=CONST:3)]
SOLUTION: [(VAR:LAURAHAIR=CONST:blonde), (VAR:LAURAHOUSE=CONST:4)]
SOLUTION: [(VAR:LAURAHAIR=CONST:blonde), (VAR:LAURAHOUSE=CONST:5)]
SOLUTION: [(VAR:LAURAHAIR=CONST:black), (VAR:LAURAHOUSE=CONST:1)]
SOLUTION: [(VAR:LAURAHAIR=CONST:black), (VAR:LAURAHOUSE=CONST:2)]
SOLUTION: [(VAR:LAURAHAIR=CONST:black), (VAR:LAURAHOUSE=CONST:3)]
SOLUTION: [(VAR:LAURAHAIR=CONST:black), (VAR:LAURAHOUSE=CONST:4)]
SOLUTION: [(VAR:LAURAHAIR=CONST:black), (VAR:LAURAHOUSE=CONST:5)]

at least one rule succeeded? true
final solution for statement <<solution3[VAR:LAURAHAIR, VAR:LAURAHOUSE]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:LAURAHAIR=CONST:grey), (VAR:LAURAHOUSE=CONST:1)]
SOLUTION: [(VAR:LAURAHAIR=CONST:grey), (VAR:LAURAHOUSE=CONST:2)]
SOLUTION: [(VAR:LAURAHAIR=CONST:grey), (VAR:LAURAHOUSE=CONST:3)]
SOLUTION: [(VAR:LAURAHAIR=CONST:grey), (VAR:LAURAHOUSE=CONST:4)]
SOLUTION: [(VAR:LAURAHAIR=CONST:grey), (VAR:LAURAHOUSE=CONST:5)]
SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut), (VAR:LAURAHOUSE=CONST:1)]
SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut), (VAR:LAURAHOUSE=CONST:2)]
SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut), (VAR:LAURAHOUSE=CONST:3)]
SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut), (VAR:LAURAHOUSE=CONST:4)]
SOLUTION: [(VAR:LAURAHAIR=CONST:chestnut), (VAR:LAURAHOUSE=CONST:5)]
SOLUTION: [(VAR:LAURAHAIR=CONST:brown), (VAR:LAURAHOUSE=CONST:1)]
SOLUTION: [(VAR:LAURAHAIR=CONST:brown), (VAR:LAURAHOUSE=CONST:2)]
SOLUTION: [(VAR:LAURAHAIR=CONST:brown), (VAR:LAURAHOUSE=CONST:3)]
SOLUTION: [(VAR:LAURAHAIR=CONST:brown), (VAR:LAURAHOUSE=CONST:4)]
SOLUTION: [(VAR:LAURAHAIR=CONST:brown), (VAR:LAURAHOUSE=CONST:5)]
SOLUTION: [(VAR:LAURAHAIR=CONST:blonde), (VAR:LAURAHOUSE=CONST:1)]
SOLUTION: [(VAR:LAURAHAIR=CONST:blonde), (VAR:LAURAHOUSE=CONST:2)]
SOLUTION: [(VAR:LAURAHAIR=CONST:blonde), (VAR:LAURAHOUSE=CONST:3)]
SOLUTION: [(VAR:LAURAHAIR=CONST:blonde), (VAR:LAURAHOUSE=CONST:4)]
SOLUTION: [(VAR:LAURAHAIR=CONST:blonde), (VAR:LAURAHOUSE=CONST:5)]
SOLUTION: [(VAR:LAURAHAIR=CONST:black), (VAR:LAURAHOUSE=CONST:1)]
SOLUTION: [(VAR:LAURAHAIR=CONST:black), (VAR:LAURAHOUSE=CONST:2)]
SOLUTION: [(VAR:LAURAHAIR=CONST:black), (VAR:LAURAHOUSE=CONST:3)]
SOLUTION: [(VAR:LAURAHAIR=CONST:black), (VAR:LAURAHOUSE=CONST:4)]
SOLUTION: [(VAR:LAURAHAIR=CONST:black), (VAR:LAURAHOUSE=CONST:5)]
>>

---------
Begin find solutions on statement: <<solution4[VAR:MOLLYHAIR, VAR:MOLLYHOUSE]>>

Matches statement? false

Applying rules for <<solution4[VAR:MOLLYHAIR, VAR:MOLLYHOUSE]>>

proving antecedent : <<hairOf[CONST:molly, VAR:MOLLYHAIR]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairOf[CONST:molly, VAR:MOLLYHAIR]>>

statement : <<hairOf[CONST:molly, VAR:MOLLYHAIR]>> matched <<hairOf[CONST:molly, CONST:black]>>
added solution for <<hairOf[CONST:molly, VAR:MOLLYHAIR]>> : solution: <<SOLUTION: [(VAR:MOLLYHAIR=CONST:black)]>>
statement : <<hairOf[CONST:molly, VAR:MOLLYHAIR]>> matched <<hairOf[CONST:molly, CONST:blonde]>>
added solution for <<hairOf[CONST:molly, VAR:MOLLYHAIR]>> : solution: <<SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde)]>>
statement : <<hairOf[CONST:molly, VAR:MOLLYHAIR]>> matched <<hairOf[CONST:molly, CONST:brown]>>
added solution for <<hairOf[CONST:molly, VAR:MOLLYHAIR]>> : solution: <<SOLUTION: [(VAR:MOLLYHAIR=CONST:brown)]>>
statement : <<hairOf[CONST:molly, VAR:MOLLYHAIR]>> matched <<hairOf[CONST:molly, CONST:chestnut]>>
added solution for <<hairOf[CONST:molly, VAR:MOLLYHAIR]>> : solution: <<SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut)]>>
statement : <<hairOf[CONST:molly, VAR:MOLLYHAIR]>> matched <<hairOf[CONST:molly, CONST:grey]>>
added solution for <<hairOf[CONST:molly, VAR:MOLLYHAIR]>> : solution: <<SOLUTION: [(VAR:MOLLYHAIR=CONST:grey)]>>
Matches statement? true
proving antecedent : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:MOLLYHAIR=CONST:black)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:brown)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:grey)]
>> with replacements <<[(VAR:MOLLYHAIR=VAR:MOLLYHAIR), (VAR:MOLLYHOUSE=VAR:MOLLYHOUSE)]>>
current statement to prove while expanding: <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:MOLLYHAIR=CONST:grey)]>>
Fully unified: houseOf[CONST:molly, VAR:MOLLYHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>>

statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:1]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut)]>>
Fully unified: houseOf[CONST:molly, VAR:MOLLYHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>>

statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:1]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:MOLLYHAIR=CONST:brown)]>>
Fully unified: houseOf[CONST:molly, VAR:MOLLYHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>>

statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:1]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde)]>>
Fully unified: houseOf[CONST:molly, VAR:MOLLYHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>>

statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:1]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:MOLLYHAIR=CONST:black)]>>
Fully unified: houseOf[CONST:molly, VAR:MOLLYHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>>

statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:1]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:2]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:3]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:4]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> matched <<houseOf[CONST:molly, CONST:5]>>
added solution for <<houseOf[CONST:molly, VAR:MOLLYHOUSE]>> : solution: <<SOLUTION: [(VAR:MOLLYHOUSE=CONST:5)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:MOLLYHAIR=CONST:grey), (VAR:MOLLYHOUSE=CONST:1)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:grey), (VAR:MOLLYHOUSE=CONST:2)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:grey), (VAR:MOLLYHOUSE=CONST:3)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:grey), (VAR:MOLLYHOUSE=CONST:4)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:grey), (VAR:MOLLYHOUSE=CONST:5)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut), (VAR:MOLLYHOUSE=CONST:1)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut), (VAR:MOLLYHOUSE=CONST:2)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut), (VAR:MOLLYHOUSE=CONST:3)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut), (VAR:MOLLYHOUSE=CONST:4)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut), (VAR:MOLLYHOUSE=CONST:5)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:brown), (VAR:MOLLYHOUSE=CONST:1)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:brown), (VAR:MOLLYHOUSE=CONST:2)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:brown), (VAR:MOLLYHOUSE=CONST:3)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:brown), (VAR:MOLLYHOUSE=CONST:4)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:brown), (VAR:MOLLYHOUSE=CONST:5)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde), (VAR:MOLLYHOUSE=CONST:1)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde), (VAR:MOLLYHOUSE=CONST:2)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde), (VAR:MOLLYHOUSE=CONST:3)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde), (VAR:MOLLYHOUSE=CONST:4)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde), (VAR:MOLLYHOUSE=CONST:5)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:black), (VAR:MOLLYHOUSE=CONST:1)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:black), (VAR:MOLLYHOUSE=CONST:2)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:black), (VAR:MOLLYHOUSE=CONST:3)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:black), (VAR:MOLLYHOUSE=CONST:4)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:black), (VAR:MOLLYHOUSE=CONST:5)]

at least one rule succeeded? true
final solution for statement <<solution4[VAR:MOLLYHAIR, VAR:MOLLYHOUSE]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:MOLLYHAIR=CONST:grey), (VAR:MOLLYHOUSE=CONST:1)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:grey), (VAR:MOLLYHOUSE=CONST:2)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:grey), (VAR:MOLLYHOUSE=CONST:3)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:grey), (VAR:MOLLYHOUSE=CONST:4)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:grey), (VAR:MOLLYHOUSE=CONST:5)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut), (VAR:MOLLYHOUSE=CONST:1)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut), (VAR:MOLLYHOUSE=CONST:2)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut), (VAR:MOLLYHOUSE=CONST:3)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut), (VAR:MOLLYHOUSE=CONST:4)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:chestnut), (VAR:MOLLYHOUSE=CONST:5)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:brown), (VAR:MOLLYHOUSE=CONST:1)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:brown), (VAR:MOLLYHOUSE=CONST:2)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:brown), (VAR:MOLLYHOUSE=CONST:3)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:brown), (VAR:MOLLYHOUSE=CONST:4)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:brown), (VAR:MOLLYHOUSE=CONST:5)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde), (VAR:MOLLYHOUSE=CONST:1)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde), (VAR:MOLLYHOUSE=CONST:2)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde), (VAR:MOLLYHOUSE=CONST:3)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde), (VAR:MOLLYHOUSE=CONST:4)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:blonde), (VAR:MOLLYHOUSE=CONST:5)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:black), (VAR:MOLLYHOUSE=CONST:1)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:black), (VAR:MOLLYHOUSE=CONST:2)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:black), (VAR:MOLLYHOUSE=CONST:3)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:black), (VAR:MOLLYHOUSE=CONST:4)]
SOLUTION: [(VAR:MOLLYHAIR=CONST:black), (VAR:MOLLYHOUSE=CONST:5)]
>>

---------
Begin find solutions on statement: <<solution5[VAR:SARAHHAIR, VAR:SARAHHOUSE]>>

Matches statement? false

Applying rules for <<solution5[VAR:SARAHHAIR, VAR:SARAHHOUSE]>>

proving antecedent : <<hairOf[CONST:sarah, VAR:SARAHHAIR]>>

Adding initial solutions
---------
Begin find solutions on statement: <<hairOf[CONST:sarah, VAR:SARAHHAIR]>>

statement : <<hairOf[CONST:sarah, VAR:SARAHHAIR]>> matched <<hairOf[CONST:sarah, CONST:black]>>
added solution for <<hairOf[CONST:sarah, VAR:SARAHHAIR]>> : solution: <<SOLUTION: [(VAR:SARAHHAIR=CONST:black)]>>
statement : <<hairOf[CONST:sarah, VAR:SARAHHAIR]>> matched <<hairOf[CONST:sarah, CONST:blonde]>>
added solution for <<hairOf[CONST:sarah, VAR:SARAHHAIR]>> : solution: <<SOLUTION: [(VAR:SARAHHAIR=CONST:blonde)]>>
statement : <<hairOf[CONST:sarah, VAR:SARAHHAIR]>> matched <<hairOf[CONST:sarah, CONST:brown]>>
added solution for <<hairOf[CONST:sarah, VAR:SARAHHAIR]>> : solution: <<SOLUTION: [(VAR:SARAHHAIR=CONST:brown)]>>
statement : <<hairOf[CONST:sarah, VAR:SARAHHAIR]>> matched <<hairOf[CONST:sarah, CONST:chestnut]>>
added solution for <<hairOf[CONST:sarah, VAR:SARAHHAIR]>> : solution: <<SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut)]>>
statement : <<hairOf[CONST:sarah, VAR:SARAHHAIR]>> matched <<hairOf[CONST:sarah, CONST:grey]>>
added solution for <<hairOf[CONST:sarah, VAR:SARAHHAIR]>> : solution: <<SOLUTION: [(VAR:SARAHHAIR=CONST:grey)]>>
Matches statement? true
proving antecedent : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>>

Expanding solution set <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:SARAHHAIR=CONST:black)]
SOLUTION: [(VAR:SARAHHAIR=CONST:blonde)]
SOLUTION: [(VAR:SARAHHAIR=CONST:brown)]
SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut)]
SOLUTION: [(VAR:SARAHHAIR=CONST:grey)]
>> with replacements <<[(VAR:SARAHHAIR=VAR:SARAHHAIR), (VAR:SARAHHOUSE=VAR:SARAHHOUSE)]>>
current statement to prove while expanding: <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:SARAHHAIR=CONST:grey)]>>
Fully unified: houseOf[CONST:sarah, VAR:SARAHHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>>

statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:1]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut)]>>
Fully unified: houseOf[CONST:sarah, VAR:SARAHHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>>

statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:1]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:SARAHHAIR=CONST:brown)]>>
Fully unified: houseOf[CONST:sarah, VAR:SARAHHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>>

statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:1]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:SARAHHAIR=CONST:blonde)]>>
Fully unified: houseOf[CONST:sarah, VAR:SARAHHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>>

statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:1]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:5)]>>
Matches statement? true
current statement to prove while expanding: <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>>
Working on solution: <<SOLUTION: [(VAR:SARAHHAIR=CONST:black)]>>
Fully unified: houseOf[CONST:sarah, VAR:SARAHHOUSE]
---------
Begin find solutions on statement: <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>>

statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:1]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:1)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:2]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:2)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:3]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:3)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:4]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:4)]>>
statement : <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> matched <<houseOf[CONST:sarah, CONST:5]>>
added solution for <<houseOf[CONST:sarah, VAR:SARAHHOUSE]>> : solution: <<SOLUTION: [(VAR:SARAHHOUSE=CONST:5)]>>
Matches statement? true
expanded solution set: QUERY true, SOLUTIONS: SOLUTION: [(VAR:SARAHHAIR=CONST:grey), (VAR:SARAHHOUSE=CONST:1)]
SOLUTION: [(VAR:SARAHHAIR=CONST:grey), (VAR:SARAHHOUSE=CONST:2)]
SOLUTION: [(VAR:SARAHHAIR=CONST:grey), (VAR:SARAHHOUSE=CONST:3)]
SOLUTION: [(VAR:SARAHHAIR=CONST:grey), (VAR:SARAHHOUSE=CONST:4)]
SOLUTION: [(VAR:SARAHHAIR=CONST:grey), (VAR:SARAHHOUSE=CONST:5)]
SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut), (VAR:SARAHHOUSE=CONST:1)]
SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut), (VAR:SARAHHOUSE=CONST:2)]
SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut), (VAR:SARAHHOUSE=CONST:3)]
SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut), (VAR:SARAHHOUSE=CONST:4)]
SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut), (VAR:SARAHHOUSE=CONST:5)]
SOLUTION: [(VAR:SARAHHAIR=CONST:brown), (VAR:SARAHHOUSE=CONST:1)]
SOLUTION: [(VAR:SARAHHAIR=CONST:brown), (VAR:SARAHHOUSE=CONST:2)]
SOLUTION: [(VAR:SARAHHAIR=CONST:brown), (VAR:SARAHHOUSE=CONST:3)]
SOLUTION: [(VAR:SARAHHAIR=CONST:brown), (VAR:SARAHHOUSE=CONST:4)]
SOLUTION: [(VAR:SARAHHAIR=CONST:brown), (VAR:SARAHHOUSE=CONST:5)]
SOLUTION: [(VAR:SARAHHAIR=CONST:blonde), (VAR:SARAHHOUSE=CONST:1)]
SOLUTION: [(VAR:SARAHHAIR=CONST:blonde), (VAR:SARAHHOUSE=CONST:2)]
SOLUTION: [(VAR:SARAHHAIR=CONST:blonde), (VAR:SARAHHOUSE=CONST:3)]
SOLUTION: [(VAR:SARAHHAIR=CONST:blonde), (VAR:SARAHHOUSE=CONST:4)]
SOLUTION: [(VAR:SARAHHAIR=CONST:blonde), (VAR:SARAHHOUSE=CONST:5)]
SOLUTION: [(VAR:SARAHHAIR=CONST:black), (VAR:SARAHHOUSE=CONST:1)]
SOLUTION: [(VAR:SARAHHAIR=CONST:black), (VAR:SARAHHOUSE=CONST:2)]
SOLUTION: [(VAR:SARAHHAIR=CONST:black), (VAR:SARAHHOUSE=CONST:3)]
SOLUTION: [(VAR:SARAHHAIR=CONST:black), (VAR:SARAHHOUSE=CONST:4)]
SOLUTION: [(VAR:SARAHHAIR=CONST:black), (VAR:SARAHHOUSE=CONST:5)]

at least one rule succeeded? true
final solution for statement <<solution5[VAR:SARAHHAIR, VAR:SARAHHOUSE]>> : <<QUERY true, SOLUTIONS: SOLUTION: [(VAR:SARAHHAIR=CONST:grey), (VAR:SARAHHOUSE=CONST:1)]
SOLUTION: [(VAR:SARAHHAIR=CONST:grey), (VAR:SARAHHOUSE=CONST:2)]
SOLUTION: [(VAR:SARAHHAIR=CONST:grey), (VAR:SARAHHOUSE=CONST:3)]
SOLUTION: [(VAR:SARAHHAIR=CONST:grey), (VAR:SARAHHOUSE=CONST:4)]
SOLUTION: [(VAR:SARAHHAIR=CONST:grey), (VAR:SARAHHOUSE=CONST:5)]
SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut), (VAR:SARAHHOUSE=CONST:1)]
SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut), (VAR:SARAHHOUSE=CONST:2)]
SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut), (VAR:SARAHHOUSE=CONST:3)]
SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut), (VAR:SARAHHOUSE=CONST:4)]
SOLUTION: [(VAR:SARAHHAIR=CONST:chestnut), (VAR:SARAHHOUSE=CONST:5)]
SOLUTION: [(VAR:SARAHHAIR=CONST:brown), (VAR:SARAHHOUSE=CONST:1)]
SOLUTION: [(VAR:SARAHHAIR=CONST:brown), (VAR:SARAHHOUSE=CONST:2)]
SOLUTION: [(VAR:SARAHHAIR=CONST:brown), (VAR:SARAHHOUSE=CONST:3)]
SOLUTION: [(VAR:SARAHHAIR=CONST:brown), (VAR:SARAHHOUSE=CONST:4)]
SOLUTION: [(VAR:SARAHHAIR=CONST:brown), (VAR:SARAHHOUSE=CONST:5)]
SOLUTION: [(VAR:SARAHHAIR=CONST:blonde), (VAR:SARAHHOUSE=CONST:1)]
SOLUTION: [(VAR:SARAHHAIR=CONST:blonde), (VAR:SARAHHOUSE=CONST:2)]
SOLUTION: [(VAR:SARAHHAIR=CONST:blonde), (VAR:SARAHHOUSE=CONST:3)]
SOLUTION: [(VAR:SARAHHAIR=CONST:blonde), (VAR:SARAHHOUSE=CONST:4)]
SOLUTION: [(VAR:SARAHHAIR=CONST:blonde), (VAR:SARAHHOUSE=CONST:5)]
SOLUTION: [(VAR:SARAHHAIR=CONST:black), (VAR:SARAHHOUSE=CONST:1)]
SOLUTION: [(VAR:SARAHHAIR=CONST:black), (VAR:SARAHHOUSE=CONST:2)]
SOLUTION: [(VAR:SARAHHAIR=CONST:black), (VAR:SARAHHOUSE=CONST:3)]
SOLUTION: [(VAR:SARAHHAIR=CONST:black), (VAR:SARAHHOUSE=CONST:4)]
SOLUTION: [(VAR:SARAHHAIR=CONST:black), (VAR:SARAHHOUSE=CONST:5)]
>>

Final merged solutions: 
QUERY true, SOLUTIONS: SOLUTION: [(VAR:W111111111=CONST:molly), (VAR:H111111111=CONST:4), (VAR:H211111111=CONST:2), (VAR:H311111111=CONST:1), (VAR:H121111111=CONST:5), (VAR:H221111111=CONST:4), (VAR:W12111111=CONST:molly), (VAR:H12111111=CONST:4), (VAR:H22111111=CONST:3), (VAR:H32111111=CONST:5), (VAR:W22111111=CONST:sarah), (VAR:W1211111=CONST:laura), (VAR:H1211111=CONST:1), (VAR:H2211111=CONST:3), (VAR:W2211111=CONST:jane), (VAR:ADELEHAIR21111=CONST:brown), (VAR:ADELEHOUSE21111=CONST:2), (VAR:JANEHAIR2111=CONST:black), (VAR:JANEHOUSE2111=CONST:3), (VAR:LAURAHAIR211=CONST:chestnut), (VAR:LAURAHOUSE211=CONST:1), (VAR:MOLLYHAIR21=CONST:blonde), (VAR:MOLLYHOUSE21=CONST:4), (VAR:SARAHHAIR2=CONST:grey), (VAR:SARAHHOUSE2=CONST:5)]

